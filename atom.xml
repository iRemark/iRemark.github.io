<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记一些·笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-22T08:05:43.465Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chuck Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS-多线程</title>
    <link href="http://yoursite.com/2019/02/22/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/22/iOS-多线程/</id>
    <published>2019-02-22T07:27:40.000Z</published>
    <updated>2019-02-22T08:05:43.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>iOS 有三种多线程编程的技术，分别是：</p><ul><li>NSThread</li><li>Cocoa NSOperation</li><li>GCD（全称：Grand Central Dispatch）</li></ul><p>三种方式的优缺点介绍：</p><p><strong>NSThread</strong><br>优点：NSThread 比其他两个轻量级<br>缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销<br>NSThread实现的技术有下面三种：(一般使用cocoa thread)<br><img src="/2019/02/22/iOS-多线程/thread.jpg" width="700" height="500" alt align="center"></p><p><strong>Cocoa NSOperation</strong><br>优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。<br>Cocoa operation 相关的类是 NSOperation ，NSOperationQueue。<br>NSOperation是个抽象类，使用它必须用它的子类，可以实现它或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。<br>创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。</p><p><strong>GCD</strong><br>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。现在的iOS系统都升级到7了，所以不用担心该技术不能使用。</p><p>介绍完这三种多线程编程方式，本文将依次介绍这三种技术的使用。</p><a id="more"></a><h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><strong>NSThread 有两种直接创建方式：</strong><br>创建方式如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(id)</span>initWithTarget:<span class="params">(id)</span>target selector:<span class="params">(SEL)</span>selector object:<span class="params">(id)</span>argument </span><br><span class="line">+ <span class="params">(void)</span>detachNewThreadSelector:<span class="params">(SEL)</span>aSelector toTarget:<span class="params">(id)</span>aTarget withObject:<span class="params">(id)</span>anArgument</span><br></pre></td></tr></table></figure><p><strong>方式1：</strong><br>该方式会直接创建线程并且开始运行线程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(doSomething:) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];   </span><br><span class="line"></span><br><span class="line"><span class="built_in">NSThread</span>* myThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span>   </span><br><span class="line">                                        selector:<span class="keyword">@selector</span>(doSomething:)   </span><br><span class="line">                                        object:<span class="literal">nil</span>];   </span><br><span class="line">[myThread start];</span><br></pre></td></tr></table></figure><blockquote><p>参数：<br>selector ：线程执行的方法，这个selector只能有一个参数，而且不能有返回值。<br>target  ：selector消息发送的对象<br>argument:传输给target的唯一参数，也可以是nil</p></blockquote><p><strong>方式2：不显式创建线程的方法:</strong><br>先创建线程对象，然后再运行线程操作，在运行线程操作前可以设置线程的优先级等线程信息<br>用NSObject的类方法  performSelectorInBackground:withObject: 创建一个线程：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">Obj</span> performSelectorInBackground:@selector(<span class="name">doSomething</span>) withObject:nil]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>下载图片的例子：</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span>   </span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)downloadImage:(<span class="built_in">NSString</span> *) url&#123;   </span><br><span class="line">    <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc] initWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:url]];   </span><br><span class="line">    <span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc]initWithData:data];   </span><br><span class="line">    <span class="keyword">if</span>(image == <span class="literal">nil</span>)&#123;   </span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;   </span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(updateUI:) withObject:image waitUntilDone:<span class="literal">YES</span>];   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)updateUI:(<span class="built_in">UIImage</span>*) image&#123;   </span><br><span class="line">    <span class="keyword">self</span>.imageView.image = image;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad   </span><br><span class="line">&#123;   </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];   </span><br><span class="line"></span><br><span class="line"><span class="comment">//    [NSThread detachNewThreadSelector:@selector(downloadImage:) toTarget:self withObject:kURL];   </span></span><br><span class="line">    <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(downloadImage:) object:kURL];   </span><br><span class="line">    [thread start];   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning   </span><br><span class="line">&#123;   </span><br><span class="line">    [<span class="keyword">super</span> didReceiveMemoryWarning];   </span><br><span class="line">    <span class="comment">// Dispose of any resources that can be recreated.   </span></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><h3 id="线程间通讯"><a href="#线程间通讯" class="headerlink" title="线程间通讯"></a>线程间通讯</h3><p>线程下载完图片后怎么通知主线程更新界面呢？<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self <span class="string">performSelectorOnMainThread:</span><span class="meta">@selector</span>(<span class="string">updateUI:</span>) <span class="string">withObject:</span>image <span class="string">waitUntilDone:</span>YES];</span><br></pre></td></tr></table></figure></p><p>performSelectorOnMainThread是NSObject的方法，除了可以更新主线程的数据外，还可以更新其他线程的比如：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">performSelector:</span><span class="string">onThread:</span><span class="string">withObject:</span><span class="string">waitUntilDone:</span></span><br></pre></td></tr></table></figure></p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>我们演示一个经典的卖票的例子来讲NSThread的线程同步：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">ViewController</span>;   </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;   </span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">int</span> tickets;   </span><br><span class="line">    <span class="keyword">int</span> count;   </span><br><span class="line">    <span class="built_in">NSThread</span>* ticketsThreadone;   </span><br><span class="line">    <span class="built_in">NSThread</span>* ticketsThreadtwo;   </span><br><span class="line">    <span class="built_in">NSCondition</span>* ticketsCondition;   </span><br><span class="line">    <span class="built_in">NSLock</span> *theLock;   </span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIWindow</span> *window;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) ViewController *viewController;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions   </span><br><span class="line">&#123;   </span><br><span class="line"></span><br><span class="line">    tickets = <span class="number">100</span>;   </span><br><span class="line">    count = <span class="number">0</span>;   </span><br><span class="line">    theLock = [[<span class="built_in">NSLock</span> alloc] init];   </span><br><span class="line">    <span class="comment">// 锁对象   </span></span><br><span class="line">    ticketsCondition = [[<span class="built_in">NSCondition</span> alloc] init];   </span><br><span class="line">    ticketsThreadone = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];   </span><br><span class="line">    [ticketsThreadone setName:<span class="string">@"Thread-1"</span>];   </span><br><span class="line">    [ticketsThreadone start];   </span><br><span class="line"></span><br><span class="line">    ticketsThreadtwo = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];   </span><br><span class="line">    [ticketsThreadtwo setName:<span class="string">@"Thread-2"</span>];   </span><br><span class="line">    [ticketsThreadtwo start];   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[[<span class="built_in">UIScreen</span> mainScreen] bounds]];   </span><br><span class="line">    <span class="comment">// Override point for customization after application launch.   </span></span><br><span class="line">    <span class="keyword">self</span>.viewController = [[ViewController alloc] initWithNibName:<span class="string">@"ViewController"</span> bundle:<span class="literal">nil</span>];   </span><br><span class="line">    <span class="keyword">self</span>.window.rootViewController = <span class="keyword">self</span>.viewController;   </span><br><span class="line">    [<span class="keyword">self</span>.window makeKeyAndVisible];   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run&#123;   </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">TRUE</span>) &#123;   </span><br><span class="line">        <span class="comment">// 上锁   </span></span><br><span class="line"><span class="comment">//        [ticketsCondition lock];   </span></span><br><span class="line">        [theLock lock];   </span><br><span class="line">        <span class="keyword">if</span>(tickets &gt;= <span class="number">0</span>)&#123;   </span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.09</span>];   </span><br><span class="line">            count = <span class="number">100</span> - tickets;   </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"当前票数是:%d,售出:%d,线程名:%@"</span>,tickets,count,[[<span class="built_in">NSThread</span> currentThread] name]);   </span><br><span class="line">            tickets--;   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;   </span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        &#125;   </span><br><span class="line">        [theLock unlock];   </span><br><span class="line"><span class="comment">//        [ticketsCondition unlock];   </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果没有线程同步的lock，卖票数可能是-1.加上lock之后线程同步保证了数据的正确性。</p><p>上面例子我使用了两种锁，一种NSCondition ，一种是：NSLock。 NSCondition我已经注释了。</p><p><strong>线程的顺序执行</strong><br>他们都可以通过[ticketsCondition signal]; 发送信号的方式，在一个线程唤醒另外一个线程的等待。</p><p>比如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span>   </span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions   </span><br><span class="line">&#123;   </span><br><span class="line"></span><br><span class="line">    tickets = <span class="number">100</span>;   </span><br><span class="line">    count = <span class="number">0</span>;   </span><br><span class="line">    theLock = [[<span class="built_in">NSLock</span> alloc] init];   </span><br><span class="line">    <span class="comment">// 锁对象   </span></span><br><span class="line">    ticketsCondition = [[<span class="built_in">NSCondition</span> alloc] init];   </span><br><span class="line">    ticketsThreadone = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];   </span><br><span class="line">    [ticketsThreadone setName:<span class="string">@"Thread-1"</span>];   </span><br><span class="line">    [ticketsThreadone start];   </span><br><span class="line"></span><br><span class="line">    ticketsThreadtwo = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];   </span><br><span class="line">    [ticketsThreadtwo setName:<span class="string">@"Thread-2"</span>];   </span><br><span class="line">    [ticketsThreadtwo start];   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSThread</span> *ticketsThreadthree = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run3) object:<span class="literal">nil</span>];   </span><br><span class="line">    [ticketsThreadthree setName:<span class="string">@"Thread-3"</span>];   </span><br><span class="line">    [ticketsThreadthree start];       </span><br><span class="line">    <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[[<span class="built_in">UIScreen</span> mainScreen] bounds]];   </span><br><span class="line">    <span class="comment">// Override point for customization after application launch.   </span></span><br><span class="line">    <span class="keyword">self</span>.viewController = [[ViewController alloc] initWithNibName:<span class="string">@"ViewController"</span> bundle:<span class="literal">nil</span>];   </span><br><span class="line">    <span class="keyword">self</span>.window.rootViewController = <span class="keyword">self</span>.viewController;   </span><br><span class="line">    [<span class="keyword">self</span>.window makeKeyAndVisible];   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)run3&#123;   </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;   </span><br><span class="line">        [ticketsCondition lock];   </span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];   </span><br><span class="line">        [ticketsCondition signal];   </span><br><span class="line">        [ticketsCondition unlock];   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run&#123;   </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">TRUE</span>) &#123;   </span><br><span class="line">        <span class="comment">// 上锁   </span></span><br><span class="line">        [ticketsCondition lock];   </span><br><span class="line">        [ticketsCondition wait];   </span><br><span class="line">        [theLock lock];   </span><br><span class="line">        <span class="keyword">if</span>(tickets &gt;= <span class="number">0</span>)&#123;   </span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.09</span>];   </span><br><span class="line">            count = <span class="number">100</span> - tickets;   </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"当前票数是:%d,售出:%d,线程名:%@"</span>,tickets,count,[[<span class="built_in">NSThread</span> currentThread] name]);   </span><br><span class="line">            tickets--;   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;   </span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        &#125;   </span><br><span class="line">        [theLock unlock];   </span><br><span class="line">        [ticketsCondition unlock];   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>wait是等待，我加了一个 线程3 去唤醒其他两个线程锁中的wait。</p><p><strong>其他同步</strong><br>我们可以使用指令 @synchronized 来简化 NSLock的使用，这样我们就不必显示编写创建NSLock,加锁并解锁相关代码。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">doSomeThing</span><span class="selector-pseudo">:(id)anObj</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="variable">@synchronized</span>(anObj) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Everything between the braces is protected by the @synchronized directive. </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有其他的一些锁对象，比如：循环锁NSRecursiveLock，条件锁NSConditionLock，分布式锁NSDistributedLock等等，可以自己看官方文档学习</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.jobbole.com/69019/" target="_blank" rel="noopener">http://blog.jobbole.com/69019/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;iOS 有三种多线程编程的技术，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSThread&lt;/li&gt;
&lt;li&gt;Cocoa NSOperation&lt;/li&gt;
&lt;li&gt;GCD（全称：Grand Central Dispatch）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种方式的优缺点介绍：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NSThread&lt;/strong&gt;&lt;br&gt;优点：NSThread 比其他两个轻量级&lt;br&gt;缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销&lt;br&gt;NSThread实现的技术有下面三种：(一般使用cocoa thread)&lt;br&gt;&lt;img src=&quot;/2019/02/22/iOS-多线程/thread.jpg&quot; width=&quot;700&quot; height=&quot;500&quot; alt align=&quot;center&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cocoa NSOperation&lt;/strong&gt;&lt;br&gt;优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。&lt;br&gt;Cocoa operation 相关的类是 NSOperation ，NSOperationQueue。&lt;br&gt;NSOperation是个抽象类，使用它必须用它的子类，可以实现它或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。&lt;br&gt;创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GCD&lt;/strong&gt;&lt;br&gt;Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。现在的iOS系统都升级到7了，所以不用担心该技术不能使用。&lt;/p&gt;
&lt;p&gt;介绍完这三种多线程编程方式，本文将依次介绍这三种技术的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>iOS 面向对象</title>
    <link href="http://yoursite.com/2019/02/22/iOS-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/02/22/iOS-面向对象/</id>
    <published>2019-02-22T06:00:12.000Z</published>
    <updated>2019-02-22T08:07:34.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象三个特性"><a href="#面向对象三个特性" class="headerlink" title="面向对象三个特性"></a>面向对象三个特性</h2><p>封装 继承 多态</p><p>封装：  一个类封装了数据以及操作数据的代码逻辑体。定义了数据的可访问属性（私有、公有）</p><p>继承 ： 可以让一个类型获取另外一个类型的属性的方式。分为实现继承和接口继承</p><p>多态 ： 类实例的一个方法在不同情形下有不同的表现形式，即不同的外在行为。使具有不同的内部结构的对象可以共享相同的外部接口。</p><h2 id="面向对象设计七大原则"><a href="#面向对象设计七大原则" class="headerlink" title="面向对象设计七大原则"></a>面向对象设计七大原则</h2><p>单一 依赖 最少　　开闭 替换 隔离　　组合/聚合</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>单一职责原则（Single Responsibility Principle）</span><br><span class="line"></span><br><span class="line">每一个类应该专注于做一件事情。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2. </span>里氏替换原则（Liskov Substitution Principle）</span><br><span class="line"></span><br><span class="line">超类存在的地方，子类是可以替换的。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3. </span>依赖倒置原则（Dependence Inversion Principle）</span><br><span class="line"></span><br><span class="line">实现尽量依赖抽象，不依赖具体实现。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4. </span>接口隔离原则（Interface Segregation Principle）</span><br><span class="line"></span><br><span class="line">应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5. </span>迪米特法则（Law Of Demeter）</span><br><span class="line"></span><br><span class="line">又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。</span><br><span class="line"></span><br><span class="line"><span class="bullet">6. </span>开闭原则（Open Close Principle）</span><br><span class="line"></span><br><span class="line">面向扩展开放，面向修改关闭。</span><br><span class="line"></span><br><span class="line"><span class="bullet">7. </span>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）</span><br><span class="line"></span><br><span class="line">尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。</span><br></pre></td></tr></table></figure> <a id="more"></a><blockquote><ol><li><strong>单一职责原则（Single Responsibility Principle）</strong></li></ol></blockquote><p>因为：</p><p>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p><p>所以：</p><p>从大局上看Android中的Paint和Canvas等类都遵守单一职责原则，Paint和Canvas各司其职。</p><blockquote><ol start="2"><li><strong>里氏替换原则（Liskov Substitution Principle）</strong></li></ol></blockquote><p>因为：</p><p>里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><p>所以：</p><p>使用里氏替换原则时需要注意，子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</p><p>从大局看Java的多态就属于这个原则。</p><blockquote><ol start="3"><li><strong>依赖倒置原则（Dependence Inversion Principle）</strong></li></ol></blockquote><p>因为：</p><p>具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。</p><p>所以：</p><p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。</p><p>从大局看Java的多态就属于这个原则。</p><blockquote><ol start="4"><li><strong>接口隔离原则（Interface Segregation Principle）</strong></li></ol></blockquote><p>因为：</p><p>提供尽可能小的单独接口，而不要提供大的总接口。暴露行为让后面的实现类知道的越少越好。譬如类ProgramMonkey通过接口CodeInterface依赖类CodeC，类ProgramMaster通过接口CodeInterface依赖类CodeAndroid，如果接口CodeInterface对于类ProgramMonkey和类CodeC来说不是最小接口，则类CodeC和类CodeAndroid必须去实现他们不需要的方法。将臃肿的接口CodeInterface拆分为独立的几个接口，类ProgramMonkey和类ProgramMaster分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p><p>所以：</p><p>建立单一接口，不要建立庞大的接口，尽量细化接口，接口中的方法尽量少。也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>从大局来说Java的接口可以实现多继承就是接口隔离原则的基础保障。</p><blockquote><ol start="5"><li><strong>迪米特法则（Law Of Demeter）</strong></li></ol></blockquote><p>因为：</p><p>类与类之间的关系越密切，耦合度也就越来越大，只有尽量降低类与类之间的耦合才符合设计模式；对于被依赖的类来说，无论逻辑多复杂都要尽量封装在类的内部；每个对象都会与其他对象有耦合关系，我们称出现成员变量、方法参数、方法返回值中的类为直接的耦合依赖，而出现在局部变量中的类则不是直接耦合依赖，也就是说，不是直接耦合依赖的类最好不要作为局部变量的形式出现在类的内部。</p><p>所以：</p><p>一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用，在一个类里能少用多少其他类就少用多少，尤其是局部变量的依赖类，能省略尽量省略。同时如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一方法的话，可以通过第三者转发这个调用。</p><p>从大局来说Android App开发中的多Fragment与依赖的Activity间交互通信遵守了这一法则。</p><blockquote><ol start="6"><li><strong>开闭原则（Open Close Principle）</strong></li></ol></blockquote><p>因为：</p><p>开放封闭原则主要体现在对扩展开放、对修改封闭，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。软件需求总是变化的，世界上没有一个软件的是不变的，因此对软件设计人员来说，必须在不需要对原有系统进行修改的情况下，实现灵活的系统扩展。</p><p>所以：</p><p>可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭，对扩展开放的设计思路。<br>封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象。</p><blockquote><ol start="7"><li><strong>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）</strong></li></ol></blockquote><p>因为：</p><p>其实整个设计模式就是在讲如何类与类之间的组合/聚合。在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。</p><p>如果为了复用，便使用继承的方式将两个不相干的类联系在一起，违反里氏代换原则，哪是生搬硬套，忽略了继承了缺点。继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用；虽然简单，但不安全，不能在程序的运行过程中随便改变；基类的实现发生了改变，派生类的实现也不得不改变；从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</p><p>所以：</p><p>组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向对象三个特性&quot;&gt;&lt;a href=&quot;#面向对象三个特性&quot; class=&quot;headerlink&quot; title=&quot;面向对象三个特性&quot;&gt;&lt;/a&gt;面向对象三个特性&lt;/h2&gt;&lt;p&gt;封装 继承 多态&lt;/p&gt;
&lt;p&gt;封装：  一个类封装了数据以及操作数据的代码逻辑体。定义了数据的可访问属性（私有、公有）&lt;/p&gt;
&lt;p&gt;继承 ： 可以让一个类型获取另外一个类型的属性的方式。分为实现继承和接口继承&lt;/p&gt;
&lt;p&gt;多态 ： 类实例的一个方法在不同情形下有不同的表现形式，即不同的外在行为。使具有不同的内部结构的对象可以共享相同的外部接口。&lt;/p&gt;
&lt;h2 id=&quot;面向对象设计七大原则&quot;&gt;&lt;a href=&quot;#面向对象设计七大原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象设计七大原则&quot;&gt;&lt;/a&gt;面向对象设计七大原则&lt;/h2&gt;&lt;p&gt;单一 依赖 最少　　开闭 替换 隔离　　组合/聚合&lt;/p&gt;
&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;1. &lt;/span&gt;单一职责原则（Single Responsibility Principle）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;每一个类应该专注于做一件事情。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;2. &lt;/span&gt;里氏替换原则（Liskov Substitution Principle）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;超类存在的地方，子类是可以替换的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;3. &lt;/span&gt;依赖倒置原则（Dependence Inversion Principle）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;实现尽量依赖抽象，不依赖具体实现。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;4. &lt;/span&gt;接口隔离原则（Interface Segregation Principle）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;5. &lt;/span&gt;迪米特法则（Law Of Demeter）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;6. &lt;/span&gt;开闭原则（Open Close Principle）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;面向扩展开放，面向修改关闭。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;7. &lt;/span&gt;组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>iOS-Runtime</title>
    <link href="http://yoursite.com/2019/02/22/iOS-Runtime/"/>
    <id>http://yoursite.com/2019/02/22/iOS-Runtime/</id>
    <published>2019-02-22T03:02:25.000Z</published>
    <updated>2019-02-22T07:14:26.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。</p><p>Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）。</p><p>Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 macOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。<br>Runtime 基本是用 C 和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在这里下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 Runtime 版本，这两个版本之间都在努力的保持一致。</p><a id="more"></a><p>平时的业务中主要是使用官方Api，解决我们框架性的需求。</p><p>高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由Runtime来实现的。然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。</p><h2 id="Runtime-API"><a href="#Runtime-API" class="headerlink" title="Runtime API"></a>Runtime API</h2><ul><li><p>使用类</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span><span class="number">_</span>getName</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getSuperclass</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>isMetaClass</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getInstanceSize</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getInstanceVariable</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getClassVariable</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>addIvar</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>copyIvarList</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getIvarLayout</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>setIvarLayout</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getWeakIvarLayout</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>setWeakIvarLayout</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getProperty</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>copyPropertyList</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>addMethod</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getInstanceMethod</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getClassMethod</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>copyMethodList</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>replaceMethod</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getMethodImplementation</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getMethodImplementation<span class="number">_</span>stret</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>respondsToSelector</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>addProtocol</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>addProperty</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>replaceProperty</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>conformsToProtocol</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>copyProtocolList</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getVersion</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>setVersion</span><br><span class="line">objc<span class="number">_</span>getFutureClass</span><br><span class="line">objc<span class="number">_</span>setFutureClass</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>setSuperclass 已过时的OS X V<span class="number">10.5</span></span><br></pre></td></tr></table></figure></li><li><p>添加类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objc_allocateClassPair</span><br><span class="line">objc_disposeClassPair</span><br><span class="line">objc_registerClassPair</span><br><span class="line">objc_duplicateClass</span><br></pre></td></tr></table></figure></li><li><p>类的实例化</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span><span class="number">_</span>createInstance</span><br><span class="line">objc<span class="number">_</span>constructInstance</span><br><span class="line">objc<span class="number">_</span>destructInstance</span><br></pre></td></tr></table></figure></li><li><p>用工作实例</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span><span class="number">_</span>copy</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>dispose</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>setInstanceVariable</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>getInstanceVariable</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>getIndexedIvars</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>getIvar</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>setIvar</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>getClassName</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>getClass</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>setClass</span><br></pre></td></tr></table></figure></li><li><p>获取类定义</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objc_getClassList</span><br><span class="line">objc_copyClassList</span><br><span class="line">objc_lookUpClass</span><br><span class="line">objc_getClass</span><br><span class="line">objc_getRequiredClass</span><br><span class="line">objc_getMetaClass</span><br></pre></td></tr></table></figure></li><li><p>使用实例变量工作</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ivar_getName</span><br><span class="line">ivar_getTypeEncoding</span><br><span class="line">ivar_getOffset</span><br></pre></td></tr></table></figure></li><li><p>联想参考</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_<span class="keyword">set</span>AssociatedObject</span><br><span class="line">objc_getAssociatedObject</span><br><span class="line">objc_removeAssociatedObjects</span><br></pre></td></tr></table></figure></li><li><p>发送消息<br>当它遇到一个方法调用时，编译器可能会生成调用任意几个函数来执行实际的消息调度，根据不同的接收器，返回值和参数。您可以使用这些功能来动态地从你自己的纯C代码中调用方法，或者使用不NSObject的公司允许说法的形式进行……方法。这些函数在声明/usr/include/objc/objc-Runtime.h。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend发送一个消息，一个简单的返回值的类的实例。</span><br><span class="line">objc_msgSend_stret发送与数据结构返回值的消息，一个类的实例。</span><br><span class="line">objc_msgSendSuper发送一个消息，一个简单的返回值的类的实例的超类。</span><br><span class="line">objc_msgSendSuper_stret发送消息与数据结构返回值的类的实例的超类。</span><br><span class="line">objc_msgSend</span><br><span class="line">objc_msgSend_fpret</span><br><span class="line">objc_msgSend_stret</span><br><span class="line">objc_msgSendSuper</span><br><span class="line">objc_msgSendSuper_stret</span><br></pre></td></tr></table></figure></li><li><p>与工作方法</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">method_invoke</span><br><span class="line">method_invoke_stret</span><br><span class="line">method_getName</span><br><span class="line">method_getImplementation</span><br><span class="line">method_getTypeEncoding</span><br><span class="line">method_copyReturnType</span><br><span class="line">method_copyArgumentType</span><br><span class="line">method_getReturnType</span><br><span class="line">method_getNumberOfArguments</span><br><span class="line">method_getArgumentType</span><br><span class="line">method_getDescription</span><br><span class="line">method_<span class="keyword">set</span>Implementation</span><br><span class="line">method_exchangeImplementations</span><br></pre></td></tr></table></figure></li><li><p>使用库</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc<span class="number">_</span>copyImageNames</span><br><span class="line"><span class="keyword">class</span><span class="number">_</span>getImageName</span><br><span class="line">objc<span class="number">_</span>copyClassNamesForImage</span><br></pre></td></tr></table></figure></li><li><p>与选择器的工作</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sel_getName</span></span><br><span class="line"><span class="keyword">sel_registerName</span></span><br><span class="line"><span class="keyword">sel_getUid</span></span><br><span class="line"><span class="keyword">sel_isEqual</span></span><br></pre></td></tr></table></figure></li><li><p>与合作协议</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">objc_getProtocol</span><br><span class="line">objc_copyProtocolList</span><br><span class="line">objc_allocateProtocol</span><br><span class="line">objc_registerProtocol</span><br><span class="line">protocol_addMethodDescription</span><br><span class="line">protocol_addProtocol</span><br><span class="line">protocol_addProperty</span><br><span class="line">protocol_getName</span><br><span class="line">protocol_isEqual</span><br><span class="line">protocol_copyMethodDescriptionList</span><br><span class="line">protocol_getMethodDescription</span><br><span class="line">protocol_copyPropertyList</span><br><span class="line">protocol_getProperty</span><br><span class="line">protocol_copyProtocolList</span><br><span class="line">protocol_conformsToProtocol</span><br></pre></td></tr></table></figure></li><li><p>与工作性质</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">property_getName</span><br><span class="line">property_getAttributes</span><br><span class="line">property_copyAttributeValue</span><br><span class="line">property_copyAttributeList</span><br></pre></td></tr></table></figure></li><li><p>使用Objective-C语言特征</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">objc_enumerationMutation</span><br><span class="line">objc_<span class="keyword">set</span>EnumerationMutationHandler</span><br><span class="line">imp_implementationWithBlock</span><br><span class="line">imp_getBlock</span><br><span class="line">imp_removeBlock</span><br><span class="line">objc_loadWeak</span><br><span class="line">objc_storeWeak</span><br></pre></td></tr></table></figure></li></ul><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><div class="row">    <embed src="../iOS-Runtime/Runtime.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h2><p><a href="https://github.com/DeveloperErenLiu/RuntimePDF" target="_blank" rel="noopener">https://github.com/DeveloperErenLiu/RuntimePDF</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5ac0a6116fb9a028de44d717" target="_blank" rel="noopener">https://juejin.im/post/5ac0a6116fb9a028de44d717</a><br><a href="https://www.cnblogs.com/zhangxiaoping/p/5146647.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangxiaoping/p/5146647.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。&lt;/p&gt;
&lt;p&gt;Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）。&lt;/p&gt;
&lt;p&gt;Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 macOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。&lt;br&gt;Runtime 基本是用 C 和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在这里下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 Runtime 版本，这两个版本之间都在努力的保持一致。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>mac-如何删除系统软件</title>
    <link href="http://yoursite.com/2019/02/18/mac-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/02/18/mac-如何删除系统软件/</id>
    <published>2019-02-18T04:54:32.000Z</published>
    <updated>2019-02-22T08:02:45.536Z</updated>
    
    <content type="html"><![CDATA[<p>mac 系统软件有保护，要关闭SIP（System Integrity Protection 系统完整性保护），然后就可以删除了。</p><p><strong>步骤1</strong>：command+r 进入恢复模式 然后打开终端输入命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">csrutil <span class="builtin-name">disable</span>　关闭SIP, 可允许删除系统软件</span><br><span class="line">csrutil <span class="builtin-name">enable</span>　 打开SIP, 不允许删除系统软件</span><br></pre></td></tr></table></figure><p><strong>步骤2</strong>：<br>现在重启后可以删除 系统软件啦 😁</p><a id="more"></a><p><strong>测试</strong>：<br>可以删除系统软件试试：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">进入软件目录：<span class="keyword">cd</span> /Applications/  然后下面开始删除试试：</span><br><span class="line"></span><br><span class="line">删除Safari浏览器：</span><br><span class="line">sudo <span class="keyword">rm</span> -rf Safari.<span class="keyword">app</span>/</span><br><span class="line"></span><br><span class="line">删除FaceTime</span><br><span class="line">sudo <span class="keyword">rm</span> -rf FaceTime.<span class="keyword">app</span>/</span><br><span class="line"></span><br><span class="line">删除QuickTime Player</span><br><span class="line">sudo <span class="keyword">rm</span> -rf QuickTime\ Player.<span class="keyword">app</span>/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mac 系统软件有保护，要关闭SIP（System Integrity Protection 系统完整性保护），然后就可以删除了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤1&lt;/strong&gt;：command+r 进入恢复模式 然后打开终端输入命令：&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;csrutil &lt;span class=&quot;builtin-name&quot;&gt;disable&lt;/span&gt;　关闭SIP, 可允许删除系统软件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;csrutil &lt;span class=&quot;builtin-name&quot;&gt;enable&lt;/span&gt;　 打开SIP, 不允许删除系统软件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;步骤2&lt;/strong&gt;：&lt;br&gt;现在重启后可以删除 系统软件啦 😁&lt;/p&gt;
    
    </summary>
    
      <category term="mac" scheme="http://yoursite.com/categories/mac/"/>
    
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
      <category term="系统" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift</title>
    <link href="http://yoursite.com/2019/02/18/RxSwift/"/>
    <id>http://yoursite.com/2019/02/18/RxSwift/</id>
    <published>2019-02-18T04:54:32.000Z</published>
    <updated>2019-02-21T09:53:07.305Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images2018.cnblogs.com/blog/948596/201806/948596-20180623211748501-430505077.jpg" width="300" height="200" alt align="center"></p><h2 id="详解-文档"><a href="#详解-文档" class="headerlink" title="详解 文档"></a>详解 文档</h2><p><a href="https://www.jianshu.com/p/b73231a29949" target="_blank" rel="noopener">Swift - RxSwift的使用详解1（基本介绍、安装配置)</a></p><p><a href="https://www.jianshu.com/p/a07ed194a276" target="_blank" rel="noopener">Swift - RxSwift的使用详解2（响应式编程与传统式编程的比较样例）</a></p><p><a href="https://www.jianshu.com/p/63f1681236fd" target="_blank" rel="noopener">Swift - RxSwift的使用详解3（Observable介绍、创建可观察序列)</a></p><a id="more"></a><p><a href="https://www.jianshu.com/p/4ce3f253dacd" target="_blank" rel="noopener">Swift - RxSwift的使用详解4（Observable订阅、事件监听、订阅销毁）</a></p><p><a href="https://www.jianshu.com/p/87a436448383" target="_blank" rel="noopener">Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder）</a></p><p><a href="https://www.jianshu.com/p/87df472317f1" target="_blank" rel="noopener">Swift - RxSwift的使用详解6（观察者2： 自定义可绑定属性）</a></p><p><a href="https://www.jianshu.com/p/def6965b0475" target="_blank" rel="noopener">Swift - RxSwift的使用详解7（Subjects、Variables）</a></p><p><a href="https://www.jianshu.com/p/c665d49c5c72" target="_blank" rel="noopener">Swift - RxSwift的使用详解8（变换操作符：buffer、map、flatMap、scan等）</a></p><p><a href="https://www.jianshu.com/p/6c593dc9091f" target="_blank" rel="noopener">Swift - RxSwift的使用详解9（过滤操作符：filter、take、skip等）</a></p><p><a href="https://www.jianshu.com/p/71b413d346c5" target="_blank" rel="noopener">Swift - RxSwift的使用详解10（条件和布尔操作符：amb、takeWhile、skipWhile等）</a></p><p><a href="https://www.jianshu.com/p/fde3d0109639" target="_blank" rel="noopener">Swift - RxSwift的使用详解11（结合操作符：startWith、merge、zip等）</a></p><p><a href="https://www.jianshu.com/p/dd0ce2de7056" target="_blank" rel="noopener">Swift - RxSwift的使用详解12（算数&amp;聚合操作符：toArray、reduce、concat）</a></p><p><a href="https://www.jianshu.com/p/64d5a52f222b" target="_blank" rel="noopener">Swift - RxSwift的使用详解13（连接操作符：connect、publish、replay、multicast）</a></p><p><a href="https://www.jianshu.com/p/2c69113856d2" target="_blank" rel="noopener">Swift - RxSwift的使用详解14（其他操作符：delay、materialize、timeout等）</a></p><p><a href="https://www.jianshu.com/p/919cc24bfdee" target="_blank" rel="noopener">Swift - RxSwift的使用详解15（错误处理）</a></p><p><a href="https://www.jianshu.com/p/7a82bbdb348d" target="_blank" rel="noopener">Swift - RxSwift的使用详解16（调试操作）</a></p><p><a href="https://www.jianshu.com/p/bc69f45938ba" target="_blank" rel="noopener">Swift - RxSwift的使用详解17（特征序列1：Single、Completable、Maybe）</a></p><p><a href="https://www.jianshu.com/p/298914bf4562" target="_blank" rel="noopener">Swift - RxSwift的使用详解18（特征序列2：Driver）</a></p><p><a href="https://www.jianshu.com/p/9adb7c778e54" target="_blank" rel="noopener">Swift - RxSwift的使用详解19（特征序列3：ControlProperty、 ControlEvent）</a></p><p><a href="https://www.jianshu.com/p/0a867b363ab2" target="_blank" rel="noopener">Swift - RxSwift的使用详解20（调度器、subscribeOn、observeOn）</a></p><p><a href="https://www.jianshu.com/p/2a5ec57f942e" target="_blank" rel="noopener">Swift - RxSwift的使用详解21（UI控件扩展1：UILabel）</a></p><p><a href="https://www.jianshu.com/p/7abbff16857e" target="_blank" rel="noopener">Swift - RxSwift的使用详解22（UI控件扩展2：UITextField、UITextView）</a></p><p><a href="https://www.jianshu.com/p/e3946f4a3c69" target="_blank" rel="noopener">Swift - RxSwift的使用详解23（UI控件扩展3：UIButton、UIBarButtonItem）</a></p><p><a href="https://www.jianshu.com/p/81f2d74d8308" target="_blank" rel="noopener">Swift - RxSwift的使用详解24（UI控件扩展4：UISwitch、UISegmentedControl）</a></p><p><a href="https://www.jianshu.com/p/004940f565f3" target="_blank" rel="noopener">Swift - RxSwift的使用详解25（UI控件扩展5：UIActivityIndicatorView、UIApplication）</a></p><p><a href="https://www.jianshu.com/p/8cff90bf9574" target="_blank" rel="noopener">Swift - RxSwift的使用详解26（UI控件扩展6：UISlider、UIStepper）</a></p><p><a href="https://www.jianshu.com/p/39fb6a65ec91" target="_blank" rel="noopener">Swift - RxSwift的使用详解27（双向绑定：&lt;-&gt;）</a></p><p><a href="https://www.jianshu.com/p/ae459de0521a" target="_blank" rel="noopener">Swift - RxSwift的使用详解28（UI控件扩展7：UIGestureRecognizer）</a></p><p><a href="https://www.jianshu.com/p/981b39db3651" target="_blank" rel="noopener">Swift - RxSwift的使用详解29（UI控件扩展8：UIDatePicker）</a></p><p><a href="https://www.jianshu.com/p/6050bc8a3211" target="_blank" rel="noopener">Swift - RxSwift的使用详解30（UITableView的使用1：基本用法）</a></p><p><a href="https://www.jianshu.com/p/4b53a8e8cfb9" target="_blank" rel="noopener">Swift - RxSwift的使用详解31（UITableView的使用2：RxDataSources）</a></p><p><a href="https://www.jianshu.com/p/9a668b4d1ea8" target="_blank" rel="noopener">Swift - RxSwift的使用详解32（UITableView的使用3：刷新表格数据）</a></p><p><a href="https://www.jianshu.com/p/023a60bc5662" target="_blank" rel="noopener">Swift - RxSwift的使用详解33（UITableView的使用4：表格数据的搜索过滤）</a></p><p><a href="https://www.jianshu.com/p/c57fa9f525f2" target="_blank" rel="noopener">Swift - RxSwift的使用详解34（UITableView的使用5：可编辑表格）</a></p><p><a href="https://www.jianshu.com/p/8f9c6482f30c" target="_blank" rel="noopener">Swift - RxSwift的使用详解35（UITableView的使用6：不同类型的单元格混用）</a></p><p><a href="https://www.jianshu.com/p/6678f28db333" target="_blank" rel="noopener">Swift - RxSwift的使用详解36（UITableView的使用7：样式修改）</a></p><p><a href="https://www.jianshu.com/p/39e7179e7a15" target="_blank" rel="noopener">Swift - RxSwift的使用详解37（UICollectionView的使用1：基本用法）</a></p><p><a href="https://www.jianshu.com/p/f89e4449875f" target="_blank" rel="noopener">Swift - RxSwift的使用详解38（UICollectionView的使用2：RxDataSources）</a></p><p><a href="https://www.jianshu.com/p/ac9adbc3a242" target="_blank" rel="noopener">Swift - RxSwift的使用详解39（UICollectionView的使用3：刷新集合数据）</a></p><p><a href="https://www.jianshu.com/p/1068d1cc6cee" target="_blank" rel="noopener">Swift - RxSwift的使用详解40（UICollectionView的使用4：样式修改）</a></p><p><a href="https://www.jianshu.com/p/26d43130e4db" target="_blank" rel="noopener">Swift - RxSwift的使用详解41（UIPickerView的使用）</a></p><p><a href="https://www.jianshu.com/p/aa702bd6ca2b" target="_blank" rel="noopener">Swift - RxSwift的使用详解42（[unowned self] 与 [weak self]）</a></p><p><a href="https://www.jianshu.com/p/a6c0c607ae0c" target="_blank" rel="noopener">Swift - RxSwift的使用详解43（URLSession的使用1：请求数据）</a></p><p><a href="https://www.jianshu.com/p/5eaa5fa2a24a" target="_blank" rel="noopener">Swift - RxSwift的使用详解44（URLSession的使用2：结果处理、模型转换）</a></p><p><a href="https://www.jianshu.com/p/e815e511dc5c" target="_blank" rel="noopener">Swift - RxSwift的使用详解45（结合RxAlamofire使用1：数据请求）</a></p><p><a href="https://www.jianshu.com/p/ab04f3587041" target="_blank" rel="noopener">Swift - RxSwift的使用详解46（结合RxAlamofire使用2：结果处理、模型转换）</a></p><p><a href="https://www.jianshu.com/p/6590324209c4" target="_blank" rel="noopener">Swift - RxSwift的使用详解47（结合RxAlamofire使用3：文件上传）</a></p><p><a href="https://www.jianshu.com/p/8fda4f3f898c" target="_blank" rel="noopener">Swift - RxSwift的使用详解48（结合RxAlamofire使用4：文件下载）</a></p><p><a href="https://www.jianshu.com/p/510ad3b8d6d7" target="_blank" rel="noopener">Swift - RxSwift的使用详解49（结合Moya使用1：数据请求）</a></p><p><a href="https://www.jianshu.com/p/173915b943af" target="_blank" rel="noopener">Swift - RxSwift的使用详解50（结合Moya使用2：结果处理、模型转换）</a></p><p><a href="https://www.jianshu.com/p/3e06e9816b93" target="_blank" rel="noopener">Swift - RxSwift的使用详解51（MVVM架构演示1：基本介绍、与MVC比较）</a></p><p><a href="https://www.jianshu.com/p/629bcd67ceda" target="_blank" rel="noopener">Swift - RxSwift的使用详解52（MVVM架构演示2：使用Observable样例）</a></p><p><a href="https://www.jianshu.com/p/565f6f369766" target="_blank" rel="noopener">Swift - RxSwift的使用详解53（MVVM架构演示3：使用Driver样例）</a></p><p><a href="https://www.jianshu.com/p/a213f644ac2f" target="_blank" rel="noopener">Swift - RxSwift的使用详解54（一个用户注册样例1：基本功能实现）</a></p><p><a href="https://www.jianshu.com/p/b3d5e8b28e93" target="_blank" rel="noopener">Swift - RxSwift的使用详解55（一个用户注册样例2：显示网络请求活动指示器）</a></p><p><a href="https://www.jianshu.com/p/736dba71cf72" target="_blank" rel="noopener">Swift - RxSwift的使用详解56（结合MJRefresh使用1：下拉刷新）</a></p><p><a href="https://www.jianshu.com/p/7da3fba72427" target="_blank" rel="noopener">Swift - RxSwift的使用详解57（结合MJRefresh使用2：上拉加载、以及上下拉组合）</a></p><p><a href="https://www.jianshu.com/p/39011740c6fc" target="_blank" rel="noopener">Swift - RxSwift的使用详解58（DelegateProxy样例1：获取地理定位信息 ）</a></p><p><a href="https://www.jianshu.com/p/081e9f2d0b12" target="_blank" rel="noopener">Swift - RxSwift的使用详解59（DelegateProxy样例2：图片选择功能 ）</a></p><p><a href="https://www.jianshu.com/p/5c941464bdf8" target="_blank" rel="noopener">Swift - RxSwift的使用详解60（DelegateProxy样例3：应用生命周期的状态变化）</a></p><p><a href="https://www.jianshu.com/p/0d2875c30083" target="_blank" rel="noopener">Swift - RxSwift的使用详解61（sendMessage和methodInvoked的区别）</a></p><p><a href="https://www.jianshu.com/p/baffcccfdf9b" target="_blank" rel="noopener">Swift - RxSwift的使用详解62 (订阅UITableViewCell里的按钮点击事件)</a></p><p><a href="https://www.jianshu.com/p/6eec28e17be7" target="_blank" rel="noopener">Swift - RxSwift的使用详解63 (通知NotificationCenter的使用)</a></p><p><a href="https://www.jianshu.com/p/ce30b9d16dc0" target="_blank" rel="noopener">Swift - RxSwift的使用详解64（键值观察KVO的使用）</a></p><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p> <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>&nbsp;QQ&nbsp;交流群:&nbsp;424180219<br> <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/" target="_blank" rel="noopener">RxSwift 中文文档 持续更新 提供电子书下载</a><br> <a href="https://store.raywenderlich.com/products/rxswift" target="_blank" rel="noopener">RxSwift RayWenderlich.com Book</a>&nbsp;&gt;&nbsp;<a href="https://pan.baidu.com/s/1nwZxz4H" target="_blank" rel="noopener">免费百度云链接</a>&nbsp;密码: ijpc</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.jianshu.com/p/f61a5a988590" target="_blank" rel="noopener">https://www.jianshu.com/p/f61a5a988590</a><br><a href="https://blog.csdn.net/zcmuczx/article/details/79008763" target="_blank" rel="noopener">https://blog.csdn.net/zcmuczx/article/details/79008763</a><br><a href="http://m.hangge.com/news/cache/category_72_5.html" target="_blank" rel="noopener">http://m.hangge.com/news/cache/category_72_5.html</a></p><p><a href="https://www.jianshu.com/p/c1494681400b" target="_blank" rel="noopener">https://www.jianshu.com/p/c1494681400b</a><br><a href="http://www.codertian.com/2017/02/04/iOS-Moya-RxSwift-better-networking/" target="_blank" rel="noopener">http://www.codertian.com/2017/02/04/iOS-Moya-RxSwift-better-networking/</a><br><a href="http://cocoadocs.org/docsets/Moya/8.0.5/index.html" target="_blank" rel="noopener">http://cocoadocs.org/docsets/Moya/8.0.5/index.html </a>//官方译文</p><h2 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h2><p><a href="https://juejin.im/post/5abba7b75188255c61631084" target="_blank" rel="noopener">https://juejin.im/post/5abba7b75188255c61631084</a><br><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html?q=" target="_blank" rel="noopener">https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html?q=&nbsp;</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/948596/201806/948596-20180623211748501-430505077.jpg&quot; width=&quot;300&quot; height=&quot;200&quot; alt align=&quot;center&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;详解-文档&quot;&gt;&lt;a href=&quot;#详解-文档&quot; class=&quot;headerlink&quot; title=&quot;详解 文档&quot;&gt;&lt;/a&gt;详解 文档&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/b73231a29949&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift - RxSwift的使用详解1（基本介绍、安装配置)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/a07ed194a276&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift - RxSwift的使用详解2（响应式编程与传统式编程的比较样例）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/63f1681236fd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift - RxSwift的使用详解3（Observable介绍、创建可观察序列)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="开发" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
