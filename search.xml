<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS-Runtime]]></title>
    <url>%2F2019%2F02%2F22%2FiOS-Runtime%2F</url>
    <content type="text"><![CDATA[简介Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）。 Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 macOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。Runtime 基本是用 C 和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在这里下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 Runtime 版本，这两个版本之间都在努力的保持一致。 平时的业务中主要是使用官方Api，解决我们框架性的需求。 高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由Runtime来实现的。然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。 Runtime API 使用类 1234567891011121314151617181920212223242526272829303132class_getNameclass_getSuperclassclass_isMetaClassclass_getInstanceSizeclass_getInstanceVariableclass_getClassVariableclass_addIvarclass_copyIvarListclass_getIvarLayoutclass_setIvarLayoutclass_getWeakIvarLayoutclass_setWeakIvarLayoutclass_getPropertyclass_copyPropertyListclass_addMethodclass_getInstanceMethodclass_getClassMethodclass_copyMethodListclass_replaceMethodclass_getMethodImplementationclass_getMethodImplementation_stretclass_respondsToSelectorclass_addProtocolclass_addPropertyclass_replacePropertyclass_conformsToProtocolclass_copyProtocolListclass_getVersionclass_setVersionobjc_getFutureClassobjc_setFutureClassclass_setSuperclass 已过时的OS X V10.5 添加类 1234objc_allocateClassPairobjc_disposeClassPairobjc_registerClassPairobjc_duplicateClass 类的实例化 123class_createInstanceobjc_constructInstanceobjc_destructInstance 用工作实例 12345678910object_copyobject_disposeobject_setInstanceVariableobject_getInstanceVariableobject_getIndexedIvarsobject_getIvarobject_setIvarobject_getClassNameobject_getClassobject_setClass 获取类定义 123456objc_getClassListobjc_copyClassListobjc_lookUpClassobjc_getClassobjc_getRequiredClassobjc_getMetaClass 使用实例变量工作 123ivar_getNameivar_getTypeEncodingivar_getOffset 联想参考 123objc_setAssociatedObjectobjc_getAssociatedObjectobjc_removeAssociatedObjects 发送消息当它遇到一个方法调用时，编译器可能会生成调用任意几个函数来执行实际的消息调度，根据不同的接收器，返回值和参数。您可以使用这些功能来动态地从你自己的纯C代码中调用方法，或者使用不NSObject的公司允许说法的形式进行……方法。这些函数在声明/usr/include/objc/objc-Runtime.h。 123456789objc_msgSend发送一个消息，一个简单的返回值的类的实例。objc_msgSend_stret发送与数据结构返回值的消息，一个类的实例。objc_msgSendSuper发送一个消息，一个简单的返回值的类的实例的超类。objc_msgSendSuper_stret发送消息与数据结构返回值的类的实例的超类。objc_msgSendobjc_msgSend_fpretobjc_msgSend_stretobjc_msgSendSuperobjc_msgSendSuper_stret 与工作方法 12345678910111213method_invokemethod_invoke_stretmethod_getNamemethod_getImplementationmethod_getTypeEncodingmethod_copyReturnTypemethod_copyArgumentTypemethod_getReturnTypemethod_getNumberOfArgumentsmethod_getArgumentTypemethod_getDescriptionmethod_setImplementationmethod_exchangeImplementations 使用库 123objc_copyImageNamesclass_getImageNameobjc_copyClassNamesForImage 与选择器的工作 1234sel_getNamesel_registerNamesel_getUidsel_isEqual 与合作协议 123456789101112131415objc_getProtocolobjc_copyProtocolListobjc_allocateProtocolobjc_registerProtocolprotocol_addMethodDescriptionprotocol_addProtocolprotocol_addPropertyprotocol_getNameprotocol_isEqualprotocol_copyMethodDescriptionListprotocol_getMethodDescriptionprotocol_copyPropertyListprotocol_getPropertyprotocol_copyProtocolListprotocol_conformsToProtocol 与工作性质 1234property_getNameproperty_getAttributesproperty_copyAttributeValueproperty_copyAttributeList 使用Objective-C语言特征 1234567objc_enumerationMutationobjc_setEnumerationMutationHandlerimp_implementationWithBlockimp_getBlockimp_removeBlockobjc_loadWeakobjc_storeWeak 引用https://juejin.im/post/5ac0a6116fb9a028de44d717https://www.cnblogs.com/zhangxiaoping/p/5146647.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS属性修修饰符]]></title>
    <url>%2F2019%2F02%2F22%2FiOS-%E5%B1%9E%E6%80%A7%E4%BF%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1.assign与weak]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac-如何删除系统软件]]></title>
    <url>%2F2019%2F02%2F18%2Fmac-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[mac 系统软件有保护，要关闭SIP（System Integrity Protection 系统完整性保护），然后就可以删除了。 步骤1：command+r 进入恢复模式 然后打开终端输入命令： 12csrutil disable 关闭SIP, 可允许删除系统软件csrutil enable 打开SIP, 不允许删除系统软件 步骤2：现在重启后可以删除 系统软件啦 😁 测试：可以删除系统软件试试： 12345678910进入软件目录：cd /Applications/ 然后下面开始删除试试：删除Safari浏览器：sudo rm -rf Safari.app/删除FaceTimesudo rm -rf FaceTime.app/删除QuickTime Playersudo rm -rf QuickTime\ Player.app/]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxSwift]]></title>
    <url>%2F2019%2F02%2F18%2FRxSwift%2F</url>
    <content type="text"><![CDATA[详解 文档Swift - RxSwift的使用详解1（基本介绍、安装配置) Swift - RxSwift的使用详解2（响应式编程与传统式编程的比较样例） Swift - RxSwift的使用详解3（Observable介绍、创建可观察序列) Swift - RxSwift的使用详解4（Observable订阅、事件监听、订阅销毁） Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder） Swift - RxSwift的使用详解6（观察者2： 自定义可绑定属性） Swift - RxSwift的使用详解7（Subjects、Variables） Swift - RxSwift的使用详解8（变换操作符：buffer、map、flatMap、scan等） Swift - RxSwift的使用详解9（过滤操作符：filter、take、skip等） Swift - RxSwift的使用详解10（条件和布尔操作符：amb、takeWhile、skipWhile等） Swift - RxSwift的使用详解11（结合操作符：startWith、merge、zip等） Swift - RxSwift的使用详解12（算数&amp;聚合操作符：toArray、reduce、concat） Swift - RxSwift的使用详解13（连接操作符：connect、publish、replay、multicast） Swift - RxSwift的使用详解14（其他操作符：delay、materialize、timeout等） Swift - RxSwift的使用详解15（错误处理） Swift - RxSwift的使用详解16（调试操作） Swift - RxSwift的使用详解17（特征序列1：Single、Completable、Maybe） Swift - RxSwift的使用详解18（特征序列2：Driver） Swift - RxSwift的使用详解19（特征序列3：ControlProperty、 ControlEvent） Swift - RxSwift的使用详解20（调度器、subscribeOn、observeOn） Swift - RxSwift的使用详解21（UI控件扩展1：UILabel） Swift - RxSwift的使用详解22（UI控件扩展2：UITextField、UITextView） Swift - RxSwift的使用详解23（UI控件扩展3：UIButton、UIBarButtonItem） Swift - RxSwift的使用详解24（UI控件扩展4：UISwitch、UISegmentedControl） Swift - RxSwift的使用详解25（UI控件扩展5：UIActivityIndicatorView、UIApplication） Swift - RxSwift的使用详解26（UI控件扩展6：UISlider、UIStepper） Swift - RxSwift的使用详解27（双向绑定：&lt;-&gt;） Swift - RxSwift的使用详解28（UI控件扩展7：UIGestureRecognizer） Swift - RxSwift的使用详解29（UI控件扩展8：UIDatePicker） Swift - RxSwift的使用详解30（UITableView的使用1：基本用法） Swift - RxSwift的使用详解31（UITableView的使用2：RxDataSources） Swift - RxSwift的使用详解32（UITableView的使用3：刷新表格数据） Swift - RxSwift的使用详解33（UITableView的使用4：表格数据的搜索过滤） Swift - RxSwift的使用详解34（UITableView的使用5：可编辑表格） Swift - RxSwift的使用详解35（UITableView的使用6：不同类型的单元格混用） Swift - RxSwift的使用详解36（UITableView的使用7：样式修改） Swift - RxSwift的使用详解37（UICollectionView的使用1：基本用法） Swift - RxSwift的使用详解38（UICollectionView的使用2：RxDataSources） Swift - RxSwift的使用详解39（UICollectionView的使用3：刷新集合数据） Swift - RxSwift的使用详解40（UICollectionView的使用4：样式修改） Swift - RxSwift的使用详解41（UIPickerView的使用） Swift - RxSwift的使用详解42（[unowned self] 与 [weak self]） Swift - RxSwift的使用详解43（URLSession的使用1：请求数据） Swift - RxSwift的使用详解44（URLSession的使用2：结果处理、模型转换） Swift - RxSwift的使用详解45（结合RxAlamofire使用1：数据请求） Swift - RxSwift的使用详解46（结合RxAlamofire使用2：结果处理、模型转换） Swift - RxSwift的使用详解47（结合RxAlamofire使用3：文件上传） Swift - RxSwift的使用详解48（结合RxAlamofire使用4：文件下载） Swift - RxSwift的使用详解49（结合Moya使用1：数据请求） Swift - RxSwift的使用详解50（结合Moya使用2：结果处理、模型转换） Swift - RxSwift的使用详解51（MVVM架构演示1：基本介绍、与MVC比较） Swift - RxSwift的使用详解52（MVVM架构演示2：使用Observable样例） Swift - RxSwift的使用详解53（MVVM架构演示3：使用Driver样例） Swift - RxSwift的使用详解54（一个用户注册样例1：基本功能实现） Swift - RxSwift的使用详解55（一个用户注册样例2：显示网络请求活动指示器） Swift - RxSwift的使用详解56（结合MJRefresh使用1：下拉刷新） Swift - RxSwift的使用详解57（结合MJRefresh使用2：上拉加载、以及上下拉组合） Swift - RxSwift的使用详解58（DelegateProxy样例1：获取地理定位信息 ） Swift - RxSwift的使用详解59（DelegateProxy样例2：图片选择功能 ） Swift - RxSwift的使用详解60（DelegateProxy样例3：应用生命周期的状态变化） Swift - RxSwift的使用详解61（sendMessage和methodInvoked的区别） Swift - RxSwift的使用详解62 (订阅UITableViewCell里的按钮点击事件) Swift - RxSwift的使用详解63 (通知NotificationCenter的使用) Swift - RxSwift的使用详解64（键值观察KVO的使用） 其他： RxSwift&nbsp;QQ&nbsp;交流群:&nbsp;424180219 RxSwift 中文文档 持续更新 提供电子书下载 RxSwift RayWenderlich.com Book&nbsp;&gt;&nbsp;免费百度云链接&nbsp;密码: ijpc 参考：https://www.jianshu.com/p/f61a5a988590https://blog.csdn.net/zcmuczx/article/details/79008763http://m.hangge.com/news/cache/category_72_5.html https://www.jianshu.com/p/c1494681400bhttp://www.codertian.com/2017/02/04/iOS-Moya-RxSwift-better-networking/http://cocoadocs.org/docsets/Moya/8.0.5/index.html //官方译文 错误处理：https://juejin.im/post/5abba7b75188255c61631084https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html?q=&nbsp;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>开发</tag>
      </tags>
  </entry>
</search>
