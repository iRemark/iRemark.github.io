<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS-多线程]]></title>
    <url>%2F2019%2F02%2F22%2FiOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介iOS 有三种多线程编程的技术，分别是： NSThread Cocoa NSOperation GCD（全称：Grand Central Dispatch） 三种方式的优缺点介绍： NSThread优点：NSThread 比其他两个轻量级缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销NSThread实现的技术有下面三种：(一般使用cocoa thread) Cocoa NSOperation优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。Cocoa operation 相关的类是 NSOperation ，NSOperationQueue。NSOperation是个抽象类，使用它必须用它的子类，可以实现它或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。 GCDGrand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。现在的iOS系统都升级到7了，所以不用担心该技术不能使用。 介绍完这三种多线程编程方式，本文将依次介绍这三种技术的使用。 NSThread创建NSThread 有两种直接创建方式：创建方式如下： 12- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument + (void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument 方式1：该方式会直接创建线程并且开始运行线程 123456[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil]; NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil]; [myThread start]; 参数：selector ：线程执行的方法，这个selector只能有一个参数，而且不能有返回值。target ：selector消息发送的对象argument:传输给target的唯一参数，也可以是nil 方式2：不显式创建线程的方法:先创建线程对象，然后再运行线程操作，在运行线程操作前可以设置线程的优先级等线程信息用NSObject的类方法 performSelectorInBackground:withObject: 创建一个线程： 1[Obj performSelectorInBackground:@selector(doSomething) withObject:nil]; 下载图片的例子：1234567891011121314151617181920212223242526272829303132@implementation ViewController -(void)downloadImage:(NSString *) url&#123; NSData *data = [[NSData alloc] initWithContentsOfURL:[NSURL URLWithString:url]]; UIImage *image = [[UIImage alloc]initWithData:data]; if(image == nil)&#123; &#125;else&#123; [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; &#125; &#125; -(void)updateUI:(UIImage*) image&#123; self.imageView.image = image; &#125; - (void)viewDidLoad &#123; [super viewDidLoad]; // [NSThread detachNewThreadSelector:@selector(downloadImage:) toTarget:self withObject:kURL]; NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(downloadImage:) object:kURL]; [thread start]; &#125; - (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. &#125; @end 线程间通讯线程下载完图片后怎么通知主线程更新界面呢？1[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; performSelectorOnMainThread是NSObject的方法，除了可以更新主线程的数据外，还可以更新其他线程的比如：1performSelector:onThread:withObject:waitUntilDone: 线程同步我们演示一个经典的卖票的例子来讲NSThread的线程同步：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#import &lt;UIKit/UIKit.h&gt; @class ViewController; @interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt; &#123; int tickets; int count; NSThread* ticketsThreadone; NSThread* ticketsThreadtwo; NSCondition* ticketsCondition; NSLock *theLock; &#125; @property (strong, nonatomic) UIWindow *window; @property (strong, nonatomic) ViewController *viewController; @end- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; tickets = 100; count = 0; theLock = [[NSLock alloc] init]; // 锁对象 ticketsCondition = [[NSCondition alloc] init]; ticketsThreadone = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadone setName:@"Thread-1"]; [ticketsThreadone start]; ticketsThreadtwo = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadtwo setName:@"Thread-2"]; [ticketsThreadtwo start]; self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // Override point for customization after application launch. self.viewController = [[ViewController alloc] initWithNibName:@"ViewController" bundle:nil]; self.window.rootViewController = self.viewController; [self.window makeKeyAndVisible]; return YES; &#125; - (void)run&#123; while (TRUE) &#123; // 上锁 // [ticketsCondition lock]; [theLock lock]; if(tickets &gt;= 0)&#123; [NSThread sleepForTimeInterval:0.09]; count = 100 - tickets; NSLog(@"当前票数是:%d,售出:%d,线程名:%@",tickets,count,[[NSThread currentThread] name]); tickets--; &#125;else&#123; break; &#125; [theLock unlock]; // [ticketsCondition unlock]; &#125; &#125; 如果没有线程同步的lock，卖票数可能是-1.加上lock之后线程同步保证了数据的正确性。 上面例子我使用了两种锁，一种NSCondition ，一种是：NSLock。 NSCondition我已经注释了。 线程的顺序执行他们都可以通过[ticketsCondition signal]; 发送信号的方式，在一个线程唤醒另外一个线程的等待。 比如：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#import "AppDelegate.h" #import "ViewController.h" @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; tickets = 100; count = 0; theLock = [[NSLock alloc] init]; // 锁对象 ticketsCondition = [[NSCondition alloc] init]; ticketsThreadone = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadone setName:@"Thread-1"]; [ticketsThreadone start]; ticketsThreadtwo = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadtwo setName:@"Thread-2"]; [ticketsThreadtwo start]; NSThread *ticketsThreadthree = [[NSThread alloc] initWithTarget:self selector:@selector(run3) object:nil]; [ticketsThreadthree setName:@"Thread-3"]; [ticketsThreadthree start]; self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // Override point for customization after application launch. self.viewController = [[ViewController alloc] initWithNibName:@"ViewController" bundle:nil]; self.window.rootViewController = self.viewController; [self.window makeKeyAndVisible]; return YES; &#125; -(void)run3&#123; while (YES) &#123; [ticketsCondition lock]; [NSThread sleepForTimeInterval:3]; [ticketsCondition signal]; [ticketsCondition unlock]; &#125; &#125; - (void)run&#123; while (TRUE) &#123; // 上锁 [ticketsCondition lock]; [ticketsCondition wait]; [theLock lock]; if(tickets &gt;= 0)&#123; [NSThread sleepForTimeInterval:0.09]; count = 100 - tickets; NSLog(@"当前票数是:%d,售出:%d,线程名:%@",tickets,count,[[NSThread currentThread] name]); tickets--; &#125;else&#123; break; &#125; [theLock unlock]; [ticketsCondition unlock]; &#125; &#125; wait是等待，我加了一个 线程3 去唤醒其他两个线程锁中的wait。 其他同步我们可以使用指令 @synchronized 来简化 NSLock的使用，这样我们就不必显示编写创建NSLock,加锁并解锁相关代码。1234567- (void)doSomeThing:(id)anObj &#123; @synchronized(anObj) &#123; // Everything between the braces is protected by the @synchronized directive. &#125; &#125; 还有其他的一些锁对象，比如：循环锁NSRecursiveLock，条件锁NSConditionLock，分布式锁NSDistributedLock等等，可以自己看官方文档学习]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-Runtime]]></title>
    <url>%2F2019%2F02%2F22%2FiOS-Runtime%2F</url>
    <content type="text"><![CDATA[简介Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）。 Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 macOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。Runtime 基本是用 C 和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在这里下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 Runtime 版本，这两个版本之间都在努力的保持一致。 平时的业务中主要是使用官方Api，解决我们框架性的需求。 高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由Runtime来实现的。然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。 Runtime API 使用类 1234567891011121314151617181920212223242526272829303132class_getNameclass_getSuperclassclass_isMetaClassclass_getInstanceSizeclass_getInstanceVariableclass_getClassVariableclass_addIvarclass_copyIvarListclass_getIvarLayoutclass_setIvarLayoutclass_getWeakIvarLayoutclass_setWeakIvarLayoutclass_getPropertyclass_copyPropertyListclass_addMethodclass_getInstanceMethodclass_getClassMethodclass_copyMethodListclass_replaceMethodclass_getMethodImplementationclass_getMethodImplementation_stretclass_respondsToSelectorclass_addProtocolclass_addPropertyclass_replacePropertyclass_conformsToProtocolclass_copyProtocolListclass_getVersionclass_setVersionobjc_getFutureClassobjc_setFutureClassclass_setSuperclass 已过时的OS X V10.5 添加类 1234objc_allocateClassPairobjc_disposeClassPairobjc_registerClassPairobjc_duplicateClass 类的实例化 123class_createInstanceobjc_constructInstanceobjc_destructInstance 用工作实例 12345678910object_copyobject_disposeobject_setInstanceVariableobject_getInstanceVariableobject_getIndexedIvarsobject_getIvarobject_setIvarobject_getClassNameobject_getClassobject_setClass 获取类定义 123456objc_getClassListobjc_copyClassListobjc_lookUpClassobjc_getClassobjc_getRequiredClassobjc_getMetaClass 使用实例变量工作 123ivar_getNameivar_getTypeEncodingivar_getOffset 联想参考 123objc_setAssociatedObjectobjc_getAssociatedObjectobjc_removeAssociatedObjects 发送消息当它遇到一个方法调用时，编译器可能会生成调用任意几个函数来执行实际的消息调度，根据不同的接收器，返回值和参数。您可以使用这些功能来动态地从你自己的纯C代码中调用方法，或者使用不NSObject的公司允许说法的形式进行……方法。这些函数在声明/usr/include/objc/objc-Runtime.h。 123456789objc_msgSend发送一个消息，一个简单的返回值的类的实例。objc_msgSend_stret发送与数据结构返回值的消息，一个类的实例。objc_msgSendSuper发送一个消息，一个简单的返回值的类的实例的超类。objc_msgSendSuper_stret发送消息与数据结构返回值的类的实例的超类。objc_msgSendobjc_msgSend_fpretobjc_msgSend_stretobjc_msgSendSuperobjc_msgSendSuper_stret 与工作方法 12345678910111213method_invokemethod_invoke_stretmethod_getNamemethod_getImplementationmethod_getTypeEncodingmethod_copyReturnTypemethod_copyArgumentTypemethod_getReturnTypemethod_getNumberOfArgumentsmethod_getArgumentTypemethod_getDescriptionmethod_setImplementationmethod_exchangeImplementations 使用库 123objc_copyImageNamesclass_getImageNameobjc_copyClassNamesForImage 与选择器的工作 1234sel_getNamesel_registerNamesel_getUidsel_isEqual 与合作协议 123456789101112131415objc_getProtocolobjc_copyProtocolListobjc_allocateProtocolobjc_registerProtocolprotocol_addMethodDescriptionprotocol_addProtocolprotocol_addPropertyprotocol_getNameprotocol_isEqualprotocol_copyMethodDescriptionListprotocol_getMethodDescriptionprotocol_copyPropertyListprotocol_getPropertyprotocol_copyProtocolListprotocol_conformsToProtocol 与工作性质 1234property_getNameproperty_getAttributesproperty_copyAttributeValueproperty_copyAttributeList 使用Objective-C语言特征 1234567objc_enumerationMutationobjc_setEnumerationMutationHandlerimp_implementationWithBlockimp_getBlockimp_removeBlockobjc_loadWeakobjc_storeWeak 详细介绍 更多资料https://github.com/DeveloperErenLiu/RuntimePDF 参考https://juejin.im/post/5ac0a6116fb9a028de44d717https://www.cnblogs.com/zhangxiaoping/p/5146647.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac-如何删除系统软件]]></title>
    <url>%2F2019%2F02%2F18%2Fmac-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[mac 系统软件有保护，要关闭SIP（System Integrity Protection 系统完整性保护），然后就可以删除了。 步骤1：command+r 进入恢复模式 然后打开终端输入命令： 12csrutil disable 关闭SIP, 可允许删除系统软件csrutil enable 打开SIP, 不允许删除系统软件 步骤2：现在重启后可以删除 系统软件啦 😁 测试：可以删除系统软件试试： 12345678910进入软件目录：cd /Applications/ 然后下面开始删除试试：删除Safari浏览器：sudo rm -rf Safari.app/删除FaceTimesudo rm -rf FaceTime.app/删除QuickTime Playersudo rm -rf QuickTime\ Player.app/]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxSwift]]></title>
    <url>%2F2019%2F02%2F18%2FRxSwift%2F</url>
    <content type="text"><![CDATA[详解 文档Swift - RxSwift的使用详解1（基本介绍、安装配置) Swift - RxSwift的使用详解2（响应式编程与传统式编程的比较样例） Swift - RxSwift的使用详解3（Observable介绍、创建可观察序列) Swift - RxSwift的使用详解4（Observable订阅、事件监听、订阅销毁） Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder） Swift - RxSwift的使用详解6（观察者2： 自定义可绑定属性） Swift - RxSwift的使用详解7（Subjects、Variables） Swift - RxSwift的使用详解8（变换操作符：buffer、map、flatMap、scan等） Swift - RxSwift的使用详解9（过滤操作符：filter、take、skip等） Swift - RxSwift的使用详解10（条件和布尔操作符：amb、takeWhile、skipWhile等） Swift - RxSwift的使用详解11（结合操作符：startWith、merge、zip等） Swift - RxSwift的使用详解12（算数&amp;聚合操作符：toArray、reduce、concat） Swift - RxSwift的使用详解13（连接操作符：connect、publish、replay、multicast） Swift - RxSwift的使用详解14（其他操作符：delay、materialize、timeout等） Swift - RxSwift的使用详解15（错误处理） Swift - RxSwift的使用详解16（调试操作） Swift - RxSwift的使用详解17（特征序列1：Single、Completable、Maybe） Swift - RxSwift的使用详解18（特征序列2：Driver） Swift - RxSwift的使用详解19（特征序列3：ControlProperty、 ControlEvent） Swift - RxSwift的使用详解20（调度器、subscribeOn、observeOn） Swift - RxSwift的使用详解21（UI控件扩展1：UILabel） Swift - RxSwift的使用详解22（UI控件扩展2：UITextField、UITextView） Swift - RxSwift的使用详解23（UI控件扩展3：UIButton、UIBarButtonItem） Swift - RxSwift的使用详解24（UI控件扩展4：UISwitch、UISegmentedControl） Swift - RxSwift的使用详解25（UI控件扩展5：UIActivityIndicatorView、UIApplication） Swift - RxSwift的使用详解26（UI控件扩展6：UISlider、UIStepper） Swift - RxSwift的使用详解27（双向绑定：&lt;-&gt;） Swift - RxSwift的使用详解28（UI控件扩展7：UIGestureRecognizer） Swift - RxSwift的使用详解29（UI控件扩展8：UIDatePicker） Swift - RxSwift的使用详解30（UITableView的使用1：基本用法） Swift - RxSwift的使用详解31（UITableView的使用2：RxDataSources） Swift - RxSwift的使用详解32（UITableView的使用3：刷新表格数据） Swift - RxSwift的使用详解33（UITableView的使用4：表格数据的搜索过滤） Swift - RxSwift的使用详解34（UITableView的使用5：可编辑表格） Swift - RxSwift的使用详解35（UITableView的使用6：不同类型的单元格混用） Swift - RxSwift的使用详解36（UITableView的使用7：样式修改） Swift - RxSwift的使用详解37（UICollectionView的使用1：基本用法） Swift - RxSwift的使用详解38（UICollectionView的使用2：RxDataSources） Swift - RxSwift的使用详解39（UICollectionView的使用3：刷新集合数据） Swift - RxSwift的使用详解40（UICollectionView的使用4：样式修改） Swift - RxSwift的使用详解41（UIPickerView的使用） Swift - RxSwift的使用详解42（[unowned self] 与 [weak self]） Swift - RxSwift的使用详解43（URLSession的使用1：请求数据） Swift - RxSwift的使用详解44（URLSession的使用2：结果处理、模型转换） Swift - RxSwift的使用详解45（结合RxAlamofire使用1：数据请求） Swift - RxSwift的使用详解46（结合RxAlamofire使用2：结果处理、模型转换） Swift - RxSwift的使用详解47（结合RxAlamofire使用3：文件上传） Swift - RxSwift的使用详解48（结合RxAlamofire使用4：文件下载） Swift - RxSwift的使用详解49（结合Moya使用1：数据请求） Swift - RxSwift的使用详解50（结合Moya使用2：结果处理、模型转换） Swift - RxSwift的使用详解51（MVVM架构演示1：基本介绍、与MVC比较） Swift - RxSwift的使用详解52（MVVM架构演示2：使用Observable样例） Swift - RxSwift的使用详解53（MVVM架构演示3：使用Driver样例） Swift - RxSwift的使用详解54（一个用户注册样例1：基本功能实现） Swift - RxSwift的使用详解55（一个用户注册样例2：显示网络请求活动指示器） Swift - RxSwift的使用详解56（结合MJRefresh使用1：下拉刷新） Swift - RxSwift的使用详解57（结合MJRefresh使用2：上拉加载、以及上下拉组合） Swift - RxSwift的使用详解58（DelegateProxy样例1：获取地理定位信息 ） Swift - RxSwift的使用详解59（DelegateProxy样例2：图片选择功能 ） Swift - RxSwift的使用详解60（DelegateProxy样例3：应用生命周期的状态变化） Swift - RxSwift的使用详解61（sendMessage和methodInvoked的区别） Swift - RxSwift的使用详解62 (订阅UITableViewCell里的按钮点击事件) Swift - RxSwift的使用详解63 (通知NotificationCenter的使用) Swift - RxSwift的使用详解64（键值观察KVO的使用） 其他： RxSwift&nbsp;QQ&nbsp;交流群:&nbsp;424180219 RxSwift 中文文档 持续更新 提供电子书下载 RxSwift RayWenderlich.com Book&nbsp;&gt;&nbsp;免费百度云链接&nbsp;密码: ijpc 参考：https://www.jianshu.com/p/f61a5a988590https://blog.csdn.net/zcmuczx/article/details/79008763http://m.hangge.com/news/cache/category_72_5.html https://www.jianshu.com/p/c1494681400bhttp://www.codertian.com/2017/02/04/iOS-Moya-RxSwift-better-networking/http://cocoadocs.org/docsets/Moya/8.0.5/index.html //官方译文 错误处理：https://juejin.im/post/5abba7b75188255c61631084https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html?q=&nbsp;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>开发</tag>
      </tags>
  </entry>
</search>
