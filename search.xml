<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mac-AppleScript]]></title>
    <url>%2F2019%2F02%2F26%2Fmac-AppleScript%2F</url>
    <content type="text"><![CDATA[简介AppleScript是苹果公司开发的一种脚本语言，可以用来控制运行于mac实现自动化的有效工具，他通过类英语的语法，以及简单的编程功能，帮助你摆脱机械化的劳动。 AppleScript 包括如下三部分： AppleScript 语言 AppleScript 脚本文件 AppleScript 脚本解释器 详细介绍]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>AppScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-多线程]]></title>
    <url>%2F2019%2F02%2F22%2FiOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介iOS 有三种多线程编程的技术，分别是： NSThread Cocoa NSOperation GCD（全称：Grand Central Dispatch） 三种方式的优缺点介绍： NSThread优点：NSThread 比其他两个轻量级缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销NSThread实现的技术有下面三种：(一般使用cocoa thread) Cocoa NSOperation优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。Cocoa operation 相关的类是 NSOperation ，NSOperationQueue。NSOperation是个抽象类，使用它必须用它的子类，可以实现它或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。 GCDGrand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。现在的iOS系统都升级到7了，所以不用担心该技术不能使用。 介绍完这三种多线程编程方式，本文将依次介绍这三种技术的使用。 NSThread创建NSThread 有两种直接创建方式：创建方式如下： 12- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument + (void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument 方式1：该方式会直接创建线程并且开始运行线程 123456[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil]; NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil]; [myThread start]; 参数：selector ：线程执行的方法，这个selector只能有一个参数，而且不能有返回值。target ：selector消息发送的对象argument:传输给target的唯一参数，也可以是nil 方式2：不显式创建线程的方法:先创建线程对象，然后再运行线程操作，在运行线程操作前可以设置线程的优先级等线程信息用NSObject的类方法 performSelectorInBackground:withObject: 创建一个线程： 1[Obj performSelectorInBackground:@selector(doSomething) withObject:nil]; 下载图片的例子：123456789101112131415161718192021222324252627282930@implementation ViewController - (void)downloadImage:(NSString *)url &#123; NSData *data = [[NSData alloc] initWithContentsOfURL:[NSURL URLWithString:url]]; UIImage *image = [[UIImage alloc]initWithData:data]; if(image == nil)&#123; &#125;else&#123; [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; &#125; &#125; - (void)updateUI:(UIImage*)image &#123; self.imageView.image = image; &#125; - (void)viewDidLoad &#123; [super viewDidLoad]; // [NSThread detachNewThreadSelector:@selector(downloadImage:) toTarget:self withObject:kURL]; NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(downloadImage:) object:kURL]; [thread start]; &#125; - (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. &#125; @end 线程间通讯线程下载完图片后怎么通知主线程更新界面呢？1[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; performSelectorOnMainThread是NSObject的方法，除了可以更新主线程的数据外，还可以更新其他线程的比如：1performSelector:onThread:withObject:waitUntilDone: 线程同步我们演示一个经典的卖票的例子来讲NSThread的线程同步：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import &lt;UIKit/UIKit.h&gt; @class ViewController; @interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt; &#123; int tickets; int count; NSThread* ticketsThreadone; NSThread* ticketsThreadtwo; NSCondition* ticketsCondition; NSLock *theLock; &#125; @property (strong, nonatomic) UIWindow *window; @property (strong, nonatomic) ViewController *viewController; @end- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; tickets = 100; count = 0; theLock = [[NSLock alloc] init]; // 锁对象 ticketsCondition = [[NSCondition alloc] init]; ticketsThreadone = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadone setName:@"Thread-1"]; [ticketsThreadone start]; ticketsThreadtwo = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadtwo setName:@"Thread-2"]; [ticketsThreadtwo start]; self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // Override point for customization after application launch. self.viewController = [[ViewController alloc] initWithNibName:@"ViewController" bundle:nil]; self.window.rootViewController = self.viewController; [self.window makeKeyAndVisible]; return YES; &#125; - (void)run &#123; while (TRUE) &#123; // 上锁 // [ticketsCondition lock]; [theLock lock]; if(tickets &gt;= 0)&#123; [NSThread sleepForTimeInterval:0.09]; count = 100 - tickets; NSLog(@"当前票数是:%d,售出:%d,线程名:%@",tickets,count,[[NSThread currentThread] name]); tickets--; &#125;else&#123; break; &#125; [theLock unlock]; // [ticketsCondition unlock]; &#125; &#125; 如果没有线程同步的lock，卖票数可能是-1.加上lock之后线程同步保证了数据的正确性。 上面例子我使用了两种锁，一种NSCondition ，一种是：NSLock。 NSCondition我已经注释了。 线程的顺序执行他们都可以通过[ticketsCondition signal]; 发送信号的方式，在一个线程唤醒另外一个线程的等待。 比如：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import "AppDelegate.h" #import "ViewController.h" @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; tickets = 100; count = 0; theLock = [[NSLock alloc] init]; // 锁对象 ticketsCondition = [[NSCondition alloc] init]; ticketsThreadone = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadone setName:@"Thread-1"]; [ticketsThreadone start]; ticketsThreadtwo = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadtwo setName:@"Thread-2"]; [ticketsThreadtwo start]; NSThread *ticketsThreadthree = [[NSThread alloc] initWithTarget:self selector:@selector(run3) object:nil]; [ticketsThreadthree setName:@"Thread-3"]; [ticketsThreadthree start]; self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // Override point for customization after application launch. self.viewController = [[ViewController alloc] initWithNibName:@"ViewController" bundle:nil]; self.window.rootViewController = self.viewController; [self.window makeKeyAndVisible]; return YES; &#125; -(void)run3&#123; while (YES) &#123; [ticketsCondition lock]; [NSThread sleepForTimeInterval:3]; [ticketsCondition signal]; [ticketsCondition unlock]; &#125; &#125; - (void)run &#123; while (TRUE) &#123; // 上锁 [ticketsCondition lock]; [ticketsCondition wait]; [theLock lock]; if(tickets &gt;= 0)&#123; [NSThread sleepForTimeInterval:0.09]; count = 100 - tickets; NSLog(@"当前票数是:%d,售出:%d,线程名:%@",tickets,count,[[NSThread currentThread] name]); tickets--; &#125;else&#123; break; &#125; [theLock unlock]; [ticketsCondition unlock]; &#125; &#125; wait是等待，我加了一个 线程3 去唤醒其他两个线程锁中的wait。 其他同步我们可以使用指令 @synchronized 来简化 NSLock的使用，这样我们就不必显示编写创建NSLock,加锁并解锁相关代码。1234567- (void)doSomeThing:(id)anObj &#123; @synchronized(anObj) &#123; // Everything between the braces is protected by the @synchronized directive. &#125; &#125; 还有其他的一些锁对象，比如：循环锁NSRecursiveLock，条件锁NSConditionLock，分布式锁NSDistributedLock等等，可以自己看官方文档学习 NSOperation使用 NSOperation的方式有两种： 一种是用定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。 一种是继承NSOperation 如果你也熟悉Java，NSOperation就和java.lang.Runnable接口很相似。和Java的Runnable一样，NSOperation也是设计用来扩展的，只需继承重写NSOperation的一个方法main。相当与java中Runnalbe的Run方法。然后把NSOperation子类的对象放入NSOperationQueue队列中，该队列就会启动并开始处理它。 NSInvocationOperation：1234567891011121314151617181920212223242526272829#import "ViewController.h" #define kURL @"http://avatar.csdn.net/2/C/D/1_totogo2010.jpg" @interface ViewController () @end @implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; NSInvocationOperation *operation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(downloadImage:) object:kURL]; NSOperationQueue *queue = [[NSOperationQueue alloc]init]; [queue addOperation:operation]; // Do any additional setup after loading the view, typically from a nib. &#125; - (void)downloadImage:(NSString *)url &#123; NSLog(@"url:%@", url); NSURL *nsUrl = [NSURL URLWithString:url]; NSData *data = [[NSData alloc]initWithContentsOfURL:nsUrl]; UIImage * image = [[UIImage alloc]initWithData:data]; [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; &#125; - (void)updateUI:(UIImage *)image &#123; self.imageView.image = image; &#125; 代码注释： viewDidLoad方法里可以看到我们用NSInvocationOperation建了一个后台线程，并且放到2.NSOperationQueue中。后台线程执行downloadImage方法。 downloadImage 方法处理下载图片的逻辑。下载完成后用performSelectorOnMainThread执行主线程updateUI方法。 updateUI 并把下载的图片显示到图片控件中。 NSOperation在.m文件中实现main方法，main方法编写要执行的代码即可。 如何控制线程池中的线程数？队列里可以加入很多个NSOperation,可以把NSOperationQueue看作一个线程池，可往线程池中添加操作（NSOperation）到队列中。线程池中的线程可看作消费者，从队列中取走操作，并执行它。 通过下面的代码设置： 1[queue setMaxConcurrentOperationCount:5]; 线程池中的线程数，也就是并发操作数。默认情况下是-1，-1表示没有限制，这样会同时运行队列中的全部的操作。 GCD的介绍和使用Grand Central Dispatch简称（GCD）是苹果公司开发的技术，以优化的应用程序支持多核心处理器和其他的对称多处理系统的系统。这建立在任务并行执行的线程池模式的基础上的。它首次发布在Mac OS X 10.6 ，iOS 4及以上也可用。 GCD的工作原理是：让程序平行排队的特定任务，根据可用的处理资源，安排他们在任何可用的处理器核心上执行任务。 一个任务可以是一个函数(function)或者是一个block。 GCD的底层依然是用线程实现，不过这样可以让程序员不用关注实现的细节。 GCD中的FIFO队列称为dispatch queue，它可以保证先进来的任务先得到执行。 dispatch queue分为下面三种： Serial又称为private dispatch queues，同时只执行一个任务。Serial queue通常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然它们各自是同步执行的，但Serial queue与Serial queue之间是并发执行的。 Concurrent又称为global dispatch queue，可以并发地执行多个任务，但是执行完成的顺序是随机的。 Main dispatch queue它是全局可用的serial queue，它是在应用程序主线程上执行任务的。 dispatch_async为了避免界面在处理耗时的操作时卡死，比如读取网络数据，IO,数据库读写等，我们会在另外一个线程中处理这些操作，然后通知主线程更新界面。 用GCD实现这个流程的操作比前面介绍的NSThread NSOperation的方法都要简单。代码框架结构如下：123456789101112131415161718dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 耗时的操作 dispatch_async(dispatch_get_main_queue(), ^&#123; // 更新界面 &#125;); &#125;);如：dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSURL * url = [NSURL URLWithString:@"http://xxxx.jpg"]; NSData * data = [[NSData alloc]initWithContentsOfURL:url]; UIImage *image = [[UIImage alloc]initWithData:data]; if (data != nil) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; &#125;); &#125; &#125;); 系统给每一个应用程序提供了三个concurrent dispatch queues。这三个并发调度队列是全局的，它们只有优先级的不同。因为是全局的，我们不需要去创建。我们只需要通过使用函数dispath_get_global_queue去得到队列，如下：1234dispatch_queue_t globalQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);这里也用到了系统默认就有一个串行队列main_queue:dispatch_queue_t mainQ = dispatch_get_main_queue(); 虽然dispatch queue是引用计数的对象，但是以上两个都是全局的队列，不用retain或release。 dispatch_group_asyncdispatch_group_async可以实现监听一组任务是否完成，完成后得到通知执行其他的操作。这个方法很有用，比如你执行三个下载任务，当三个任务都下载完成后你才通知界面说完成的了。123456789101112131415161718dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@"group1"); &#125;); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@"group2"); &#125;); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:3]; NSLog(@"group3"); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@"updateUi"); &#125;); dispatch_release(group); dispatch_group_async是异步的方法，运行后可以看到打印结果： 12342012-09-25 16:04:16.737 gcdTest[43328:11303] group1 2012-09-25 16:04:17.738 gcdTest[43328:12a1b] group2 2012-09-25 16:04:18.738 gcdTest[43328:13003] group3 2012-09-25 16:04:18.739 gcdTest[43328:f803] updateUi 每个一秒打印一个，当第三个任务执行后，upadteUi被打印。 dispatch_barrier_asyncdispatch_barrier_async是在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行:123456789101112131415161718dispatch_queue_t queue = dispatch_queue_create("com.chuck.test", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@"dispatch_async1"); &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:4]; NSLog(@"dispatch_async2"); &#125;); dispatch_barrier_async(queue, ^&#123; NSLog(@"dispatch_barrier_async"); [NSThread sleepForTimeInterval:4]; &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@"dispatch_async3"); &#125;); 打印结果：12342012-09-25 16:20:33.967 gcdTest[45547:11203] dispatch_async1 2012-09-25 16:20:35.967 gcdTest[45547:11303] dispatch_async2 2012-09-25 16:20:35.967 gcdTest[45547:11303] dispatch_barrier_async 2012-09-25 16:20:40.970 gcdTest[45547:11303] dispatch_async3 请注意执行的时间，可以看到执行的顺序如上所述。 dispatch_apply执行某个代码片段N次。123dispatch_apply(5, globalQ, ^(size_t index) &#123; // 执行5次 &#125;); 参考http://blog.jobbole.com/69019/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 面向对象]]></title>
    <url>%2F2019%2F02%2F22%2FiOS-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象三个特性封装 继承 多态 封装一个类封装了数据以及操作数据的代码逻辑体。定义了数据的可访问属性（私有、公有） 继承可以让一个类型获取另外一个类型的属性的方式。分为实现继承和接口继承 多态类实例的一个方法在不同情形下有不同的表现形式，即不同的外在行为。使具有不同的内部结构的对象可以共享相同的外部接口。 面向对象设计七大原则单一 依赖 最少 开闭 替换 隔离 组合/聚合 1234567891011121314151617181920212223242526271. 单一职责原则（Single Responsibility Principle）每一个类应该专注于做一件事情。2. 里氏替换原则（Liskov Substitution Principle）超类存在的地方，子类是可以替换的。3. 依赖倒置原则（Dependence Inversion Principle）实现尽量依赖抽象，不依赖具体实现。4. 接口隔离原则（Interface Segregation Principle）应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。5. 迪米特法则（Law Of Demeter）又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。6. 开闭原则（Open Close Principle）面向扩展开放，面向修改关闭。7. 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。 1. 单一职责原则（Single Responsibility Principle）因为： 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。 所以： 从大局上看Android中的Paint和Canvas等类都遵守单一职责原则，Paint和Canvas各司其职。 2. 里氏替换原则（Liskov Substitution Principle）因为： 里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 所以： 使用里氏替换原则时需要注意，子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。 从大局看Java的多态就属于这个原则。 3. 依赖倒置原则（Dependence Inversion Principle）因为： 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。 所以： 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。 从大局看Java的多态就属于这个原则。 4. 接口隔离原则（Interface Segregation Principle）因为： 提供尽可能小的单独接口，而不要提供大的总接口。暴露行为让后面的实现类知道的越少越好。譬如类ProgramMonkey通过接口CodeInterface依赖类CodeC，类ProgramMaster通过接口CodeInterface依赖类CodeAndroid，如果接口CodeInterface对于类ProgramMonkey和类CodeC来说不是最小接口，则类CodeC和类CodeAndroid必须去实现他们不需要的方法。将臃肿的接口CodeInterface拆分为独立的几个接口，类ProgramMonkey和类ProgramMaster分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。 所以： 建立单一接口，不要建立庞大的接口，尽量细化接口，接口中的方法尽量少。也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 从大局来说Java的接口可以实现多继承就是接口隔离原则的基础保障。 5. 迪米特法则（Law Of Demeter）因为： 类与类之间的关系越密切，耦合度也就越来越大，只有尽量降低类与类之间的耦合才符合设计模式；对于被依赖的类来说，无论逻辑多复杂都要尽量封装在类的内部；每个对象都会与其他对象有耦合关系，我们称出现成员变量、方法参数、方法返回值中的类为直接的耦合依赖，而出现在局部变量中的类则不是直接耦合依赖，也就是说，不是直接耦合依赖的类最好不要作为局部变量的形式出现在类的内部。 所以： 一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用，在一个类里能少用多少其他类就少用多少，尤其是局部变量的依赖类，能省略尽量省略。同时如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一方法的话，可以通过第三者转发这个调用。 从大局来说Android App开发中的多Fragment与依赖的Activity间交互通信遵守了这一法则。 6. 开闭原则（Open Close Principle）因为： 开放封闭原则主要体现在对扩展开放、对修改封闭，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。软件需求总是变化的，世界上没有一个软件的是不变的，因此对软件设计人员来说，必须在不需要对原有系统进行修改的情况下，实现灵活的系统扩展。 所以： 可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭，对扩展开放的设计思路。封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象。 7. 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）因为： 其实整个设计模式就是在讲如何类与类之间的组合/聚合。在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。 如果为了复用，便使用继承的方式将两个不相干的类联系在一起，违反里氏代换原则，哪是生搬硬套，忽略了继承了缺点。继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用；虽然简单，但不安全，不能在程序的运行过程中随便改变；基类的实现发生了改变，派生类的实现也不得不改变；从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。 所以： 组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-Runtime]]></title>
    <url>%2F2019%2F02%2F22%2FiOS-Runtime%2F</url>
    <content type="text"><![CDATA[简介Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）。 Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 macOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。Runtime 基本是用 C 和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在这里下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 Runtime 版本，这两个版本之间都在努力的保持一致。 平时的业务中主要是使用官方Api，解决我们框架性的需求。 高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由Runtime来实现的。然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。 Runtime API 使用类 1234567891011121314151617181920212223242526272829303132class_getNameclass_getSuperclassclass_isMetaClassclass_getInstanceSizeclass_getInstanceVariableclass_getClassVariableclass_addIvarclass_copyIvarListclass_getIvarLayoutclass_setIvarLayoutclass_getWeakIvarLayoutclass_setWeakIvarLayoutclass_getPropertyclass_copyPropertyListclass_addMethodclass_getInstanceMethodclass_getClassMethodclass_copyMethodListclass_replaceMethodclass_getMethodImplementationclass_getMethodImplementation_stretclass_respondsToSelectorclass_addProtocolclass_addPropertyclass_replacePropertyclass_conformsToProtocolclass_copyProtocolListclass_getVersionclass_setVersionobjc_getFutureClassobjc_setFutureClassclass_setSuperclass 已过时的OS X V10.5 添加类 1234objc_allocateClassPairobjc_disposeClassPairobjc_registerClassPairobjc_duplicateClass 类的实例化 123class_createInstanceobjc_constructInstanceobjc_destructInstance 用工作实例 12345678910object_copyobject_disposeobject_setInstanceVariableobject_getInstanceVariableobject_getIndexedIvarsobject_getIvarobject_setIvarobject_getClassNameobject_getClassobject_setClass 获取类定义 123456objc_getClassListobjc_copyClassListobjc_lookUpClassobjc_getClassobjc_getRequiredClassobjc_getMetaClass 使用实例变量工作 123ivar_getNameivar_getTypeEncodingivar_getOffset 联想参考 123objc_setAssociatedObjectobjc_getAssociatedObjectobjc_removeAssociatedObjects 发送消息当它遇到一个方法调用时，编译器可能会生成调用任意几个函数来执行实际的消息调度，根据不同的接收器，返回值和参数。您可以使用这些功能来动态地从你自己的纯C代码中调用方法，或者使用不NSObject的公司允许说法的形式进行……方法。这些函数在声明/usr/include/objc/objc-Runtime.h。 123456789objc_msgSend发送一个消息，一个简单的返回值的类的实例。objc_msgSend_stret发送与数据结构返回值的消息，一个类的实例。objc_msgSendSuper发送一个消息，一个简单的返回值的类的实例的超类。objc_msgSendSuper_stret发送消息与数据结构返回值的类的实例的超类。objc_msgSendobjc_msgSend_fpretobjc_msgSend_stretobjc_msgSendSuperobjc_msgSendSuper_stret 与工作方法 12345678910111213method_invokemethod_invoke_stretmethod_getNamemethod_getImplementationmethod_getTypeEncodingmethod_copyReturnTypemethod_copyArgumentTypemethod_getReturnTypemethod_getNumberOfArgumentsmethod_getArgumentTypemethod_getDescriptionmethod_setImplementationmethod_exchangeImplementations 使用库 123objc_copyImageNamesclass_getImageNameobjc_copyClassNamesForImage 与选择器的工作 1234sel_getNamesel_registerNamesel_getUidsel_isEqual 与合作协议 123456789101112131415objc_getProtocolobjc_copyProtocolListobjc_allocateProtocolobjc_registerProtocolprotocol_addMethodDescriptionprotocol_addProtocolprotocol_addPropertyprotocol_getNameprotocol_isEqualprotocol_copyMethodDescriptionListprotocol_getMethodDescriptionprotocol_copyPropertyListprotocol_getPropertyprotocol_copyProtocolListprotocol_conformsToProtocol 与工作性质 1234property_getNameproperty_getAttributesproperty_copyAttributeValueproperty_copyAttributeList 使用Objective-C语言特征 1234567objc_enumerationMutationobjc_setEnumerationMutationHandlerimp_implementationWithBlockimp_getBlockimp_removeBlockobjc_loadWeakobjc_storeWeak 详细介绍 更多资料https://github.com/DeveloperErenLiu/RuntimePDF 参考https://juejin.im/post/5ac0a6116fb9a028de44d717https://www.cnblogs.com/zhangxiaoping/p/5146647.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac-如何删除系统软件]]></title>
    <url>%2F2019%2F02%2F18%2Fmac-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[mac 系统软件有保护，要关闭SIP（System Integrity Protection 系统完整性保护），然后就可以删除了。 步骤1：command+r 进入恢复模式 然后打开终端输入命令： 12csrutil disable 关闭SIP, 可允许删除系统软件csrutil enable 打开SIP, 不允许删除系统软件 步骤2：现在重启后可以删除 系统软件啦 😁 测试：可以删除系统软件试试： 12345678910进入软件目录：cd /Applications/ 然后下面开始删除试试：删除Safari浏览器：sudo rm -rf Safari.app/删除FaceTimesudo rm -rf FaceTime.app/删除QuickTime Playersudo rm -rf QuickTime\ Player.app/]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxSwift]]></title>
    <url>%2F2019%2F02%2F18%2FRxSwift%2F</url>
    <content type="text"><![CDATA[详解 文档Swift - RxSwift的使用详解1（基本介绍、安装配置) Swift - RxSwift的使用详解2（响应式编程与传统式编程的比较样例） Swift - RxSwift的使用详解3（Observable介绍、创建可观察序列) Swift - RxSwift的使用详解4（Observable订阅、事件监听、订阅销毁） Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder） Swift - RxSwift的使用详解6（观察者2： 自定义可绑定属性） Swift - RxSwift的使用详解7（Subjects、Variables） Swift - RxSwift的使用详解8（变换操作符：buffer、map、flatMap、scan等） Swift - RxSwift的使用详解9（过滤操作符：filter、take、skip等） Swift - RxSwift的使用详解10（条件和布尔操作符：amb、takeWhile、skipWhile等） Swift - RxSwift的使用详解11（结合操作符：startWith、merge、zip等） Swift - RxSwift的使用详解12（算数&amp;聚合操作符：toArray、reduce、concat） Swift - RxSwift的使用详解13（连接操作符：connect、publish、replay、multicast） Swift - RxSwift的使用详解14（其他操作符：delay、materialize、timeout等） Swift - RxSwift的使用详解15（错误处理） Swift - RxSwift的使用详解16（调试操作） Swift - RxSwift的使用详解17（特征序列1：Single、Completable、Maybe） Swift - RxSwift的使用详解18（特征序列2：Driver） Swift - RxSwift的使用详解19（特征序列3：ControlProperty、 ControlEvent） Swift - RxSwift的使用详解20（调度器、subscribeOn、observeOn） Swift - RxSwift的使用详解21（UI控件扩展1：UILabel） Swift - RxSwift的使用详解22（UI控件扩展2：UITextField、UITextView） Swift - RxSwift的使用详解23（UI控件扩展3：UIButton、UIBarButtonItem） Swift - RxSwift的使用详解24（UI控件扩展4：UISwitch、UISegmentedControl） Swift - RxSwift的使用详解25（UI控件扩展5：UIActivityIndicatorView、UIApplication） Swift - RxSwift的使用详解26（UI控件扩展6：UISlider、UIStepper） Swift - RxSwift的使用详解27（双向绑定：&lt;-&gt;） Swift - RxSwift的使用详解28（UI控件扩展7：UIGestureRecognizer） Swift - RxSwift的使用详解29（UI控件扩展8：UIDatePicker） Swift - RxSwift的使用详解30（UITableView的使用1：基本用法） Swift - RxSwift的使用详解31（UITableView的使用2：RxDataSources） Swift - RxSwift的使用详解32（UITableView的使用3：刷新表格数据） Swift - RxSwift的使用详解33（UITableView的使用4：表格数据的搜索过滤） Swift - RxSwift的使用详解34（UITableView的使用5：可编辑表格） Swift - RxSwift的使用详解35（UITableView的使用6：不同类型的单元格混用） Swift - RxSwift的使用详解36（UITableView的使用7：样式修改） Swift - RxSwift的使用详解37（UICollectionView的使用1：基本用法） Swift - RxSwift的使用详解38（UICollectionView的使用2：RxDataSources） Swift - RxSwift的使用详解39（UICollectionView的使用3：刷新集合数据） Swift - RxSwift的使用详解40（UICollectionView的使用4：样式修改） Swift - RxSwift的使用详解41（UIPickerView的使用） Swift - RxSwift的使用详解42（[unowned self] 与 [weak self]） Swift - RxSwift的使用详解43（URLSession的使用1：请求数据） Swift - RxSwift的使用详解44（URLSession的使用2：结果处理、模型转换） Swift - RxSwift的使用详解45（结合RxAlamofire使用1：数据请求） Swift - RxSwift的使用详解46（结合RxAlamofire使用2：结果处理、模型转换） Swift - RxSwift的使用详解47（结合RxAlamofire使用3：文件上传） Swift - RxSwift的使用详解48（结合RxAlamofire使用4：文件下载） Swift - RxSwift的使用详解49（结合Moya使用1：数据请求） Swift - RxSwift的使用详解50（结合Moya使用2：结果处理、模型转换） Swift - RxSwift的使用详解51（MVVM架构演示1：基本介绍、与MVC比较） Swift - RxSwift的使用详解52（MVVM架构演示2：使用Observable样例） Swift - RxSwift的使用详解53（MVVM架构演示3：使用Driver样例） Swift - RxSwift的使用详解54（一个用户注册样例1：基本功能实现） Swift - RxSwift的使用详解55（一个用户注册样例2：显示网络请求活动指示器） Swift - RxSwift的使用详解56（结合MJRefresh使用1：下拉刷新） Swift - RxSwift的使用详解57（结合MJRefresh使用2：上拉加载、以及上下拉组合） Swift - RxSwift的使用详解58（DelegateProxy样例1：获取地理定位信息 ） Swift - RxSwift的使用详解59（DelegateProxy样例2：图片选择功能 ） Swift - RxSwift的使用详解60（DelegateProxy样例3：应用生命周期的状态变化） Swift - RxSwift的使用详解61（sendMessage和methodInvoked的区别） Swift - RxSwift的使用详解62 (订阅UITableViewCell里的按钮点击事件) Swift - RxSwift的使用详解63 (通知NotificationCenter的使用) Swift - RxSwift的使用详解64（键值观察KVO的使用） 其他： RxSwift&nbsp;QQ&nbsp;交流群:&nbsp;424180219 RxSwift 中文文档 持续更新 提供电子书下载 RxSwift RayWenderlich.com Book&nbsp;&gt;&nbsp;免费百度云链接&nbsp;密码: ijpc 参考：https://www.jianshu.com/p/f61a5a988590https://blog.csdn.net/zcmuczx/article/details/79008763http://m.hangge.com/news/cache/category_72_5.html https://www.jianshu.com/p/c1494681400bhttp://www.codertian.com/2017/02/04/iOS-Moya-RxSwift-better-networking/http://cocoadocs.org/docsets/Moya/8.0.5/index.html //官方译文 错误处理：https://juejin.im/post/5abba7b75188255c61631084https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html?q=&nbsp;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>开发</tag>
      </tags>
  </entry>
</search>
